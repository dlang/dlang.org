Ddoc

$(D_S rdmd,

<h2>Synopsis</h2>

In a command prompt:
<pre>
% cat myprog.d
import std.stdio;
void main() 
{
    writeln("Hello, world without explicit compilations!"); 
}
% rdmd myprog
Hello, world without explicit compilations!
% <blink>_</blink>
</pre>

Inside a D program:
<pre>
% cat myprog.d
#!/usr/bin/rdmd
import std.stdio;
void main() 
{
    writeln("Hello, world with automated script running!"); 
}
% ./myprog.d
Hello, world with automated script running!
% <blink>_</blink>
</pre>

(Under Windows replace $(B cat) with $(B type) and $(B
#!/usr/bin/rdmd) with $(B #!rdmd), the latter assuming that $(B rdmd)
can be found in your path.)

<h2>Description</h2>

$(P $(B rdmd) is a companion to the $(B dmd) compiler that simplifies
the typical edit-compile-link-run or edit-make-run cycle to a rapid
edit-run cycle. Like $(B make) and other tools, $(B rdmd) uses the
relative dates of the files involved to minimize the amount of work
necessary. Unlike $(B make), $(B rdmd) tracks dependencies and
freshness without requiring additional information from the user.)

$(P $(B rdmd): $(UL 

$(LI shields its user from the notion that producing a running program
from D programming language files may entail several concerted steps
against different source files producing various intermediate files;)

$(LI automatically infers and builds dependent files, transitively, by
following $(B import) directives;)

$(LI recognizes and passes down all of $(B dmd)'s command-line options;)

$(LI understands how various $(B dmd) compiler options (e.g. $(B
-release) vs. $(B -debug)) affect generation of intermediate files,
and avoids conflations (e.g., does not unwittingly run a debug
executable when the release executable is asked for);)

$(LI recompiles files only on a needed basis, e.g. two invocations of
$(B rdmd) in sequence without an intervening change to any relevant
source file does not produce the executable again.)

))

<h2>Usage</h2>

$(P
        $(B rdmd) [$(I dmd and rdmd options)] $(I progfile)[.d] [$(I program arguments)]
)

$(P In addition to $(B dmd)'s options, $(B rdmd) recognizes the following:
)

$(DL 

$(DT $(B --chatty)) $(DD write dmd commands to stdout before executing
them)

$(DT $(B --compiler)=/path/to/compiler) $(DD use the specified
compiler (e.g. gdmd) instead of dmd)

$(DT $(B --dry-run)) $(DD do not compile, just show what commands
would be run (implies --chatty))

$(DT $(B --eval)=code) $(DD evaluate code including it in $(D_PARAM
void main(char[][] args) { ... }) (multiple --eval allowed, will be
evaluated in turn))

$(DT $(B --force)) $(DD force a rebuild even if apparently not
necessary)

$(DT $(B --help)) $(DD show a help message and exit)

$(DT $(B --loop)=code) $(DD like --eval, but code will be additionally
included in a loop $(D_PARAM foreach (line; stdin.byLine()) { ... }))

$(DT $(B --main)) $(DD add an empty $(D_PARAM void main() {}) function
(useful for running unittests))

$(DT $(B --man)) $(DD open web browser on manual page)
)

<h2>Download</h2>

$(UL $(LI View syntax-colored $(LINK2
http://dsource.org/projects/phobos/browser/trunk/tools/rdmd.d, source
code))

$(LI $(LINK2
http://dsource.org/projects/phobos/browser/trunk/tools/rdmd.d?format=txt,
Download)))

<h2>Author</h2>

$(LINK2 http://erdani.org, Andrei Alexandrescu)
)

Macros:
	TITLE=rdmd
	WIKI=rdmd

