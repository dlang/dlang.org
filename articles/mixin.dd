Ddoc

$(D_S String Mixins,

$(HEADERNAV_TOC)

        $(P String mixins (not to be confused with
        $(DDLINK spec/template-mixin, Template Mixins, template mixins))
        enable string constants to be compiled as regular D code
        and inserted into the program.
        String mixins can be used in place of:)

        $(UL
        $(LI Declarations)
        $(LI Statements)
        $(LI Types)
        $(LI Expressions)
        )

$(H2 $(LNAME2 declarations, Generating Declarations))

        $(P A mixin can be used for a variable declaration:)
---
enum s = "int y;";
mixin(s);
y = 4;     // ok, mixin declared y
---

        $(P We can generate a declaration `struct Foo { int bar; }`
        using string constants for the identifiers:
        )

---
enum name = "Foo";
enum m1 = "bar";
mixin("struct " ~ name ~
    "{ int " ~ m1 ~ "; }");

enum f = Foo(2);
static assert(f.bar == 2);
---
        $(P This can be encapsulated in an enum template for reuse:)
---
enum string genStruct(string name, string m1) =
    "struct " ~ name ~ "{ int " ~ m1 ~ "; }";

mixin(genStruct!("Foo", "bar"));
---

$(H2 $(LNAME2 multiple-args, Concatenation of Multiple Arguments))

        $(P `mixin()` can also concatenate multiple arguments, converting any
        non-strings to strings:)
---
enum name = "Foo";
enum m1 = "bar";
$(CODE_HIGHLIGHT enum val = 4;)
mixin("struct ", name,
    "{ int ", m1, " = ", $(CODE_HIGHLIGHT val), "; }");

enum f = Foo();
static assert(f.bar == 4);
---

$(H2 $(LNAME2 statements, Generating Statements))

---
int x = 3;
mixin("
    foreach (i; 0 .. 3)
        writeln(x + i);
    ");
---
        $(P This outputs:)
$(CONSOLE
3
4
5
)
        $(P See also: $(GLINK2 statement, MixinStatement).)

$(H2 $(LNAME2 types, Generating Types))

---
mixin("int")* p;  // int* p
mixin("int")[] a; // int[] a;
mixin("int[]") b; // int[] b;
---

$(H2 $(LNAME2 expressions, Generating Expressions))

---
int foo(int x)
{
    return mixin("x +", 1) * 7;  // same as `return (x + 1) * 7`
}
---

$(H2 $(LNAME2 dsl, Domain Specific Languages))

        $(P
        Combining compile-time function execution with `mixin()`
        enables the use of domain-specific languages:)
        ---
        mixin(convertJS(q{
            var msg = "Hello world!"
            console.log(msg)
            msg = 5
            console.log(msg)
            }));
        ---
        $(P `convertJS` would generate a string that would be compiled
        to the following D code:)
        ---
        import std.variant;

        Variant msg = "Hello world!";
        writeln(msg);
        msg = 5;
        writeln(msg);
        ---

        $(NOTE Text editors can syntax highlight the contents of `q{}`
        strings as D tokens rather than a string, which is useful with
        `mixin()`. The above JS code happens to be token compatible
        with D.)

$(H2 $(LNAME2 cpp, Comparison with C preprocessor))

        $(P Superficially, since D mixins can manipulate text and compile
        the result, it has some similar properties to the C preprocessor.
        But there are major, fundamental differences:
        )

$(UL

        $(LI The C preprocessing step occurs $(B before) lexical analysis.
        This makes it impossible to lex or parse C without access to
        all of the context, including all #include'd files, paths and all
        relevant compiler switches.

        Mixins occur during semantic analysis, and do not affect
        the lexing or parsing process.
        Lexing and parsing can still occur without semantic analysis.
        )


        $(LI The C preprocessor can be used to create what appears to
        be different syntax:

$(CCODE
#define BEGIN {
#define END   }

BEGIN
  int x = 3;
  foo(x);
END
)

        This monkey business is impossible with mixins.
        Mixed in text must form complete declarations,
        statements, types, or expressions.
        )

        $(LI C macros will affect everything following that has
        the same name, even if they are in nested scopes.
        C macros cut across all scopes.
        This problem is called being not "coding hygenic".

        Mixins follow the usual scoping rules, and is
        hygenic.
        )

        $(LI C preprocessing expressions follow a different syntax
        and have different semantic rules than the C language.
        The C preprocessor is technically a different language.

        Mixins are in the same language.
        )

        $(LI C const declarations and C++ templates are invisible
        to C preprocessing.

        Mixins can be manipulated using templates and const
        declarations.
        )
)

)

Macros:
        TITLE=String Mixins
        SUBNAV=$(SUBNAV_ARTICLES)
        NOTE= $(DIVC note, $(B Note:) $0)
