Ddoc

$(SPEC_S Expressions,

$(HEADERNAV_TOC)

    $(P Expressions are used to compute values with a resulting type.
        These values can then be assigned,
        tested, or ignored. Expressions can also have side effects.
    )

$(H2 $(LNAME2 order-of-evaluation, Order Of Evaluation))

$(P Binary expressions and function arguments are evaluated in strictly
left-to-right order.)

        -------------
        import std.conv;
        int i = 0;
        (i = 2) = ++i * i++ + i;
        assert(i == 13); // left to right evaluation of side effects
        assert(text(++i, ++i) == "1415"); // left to right evaluation of arguments
        -------------

    $(IMPLEMENTATION_DEFINED
    $(OL
    $(LI The order of evaluation of the operands of $(GLINK AssignExpression).)
    $(LI The order of evaluation of function arguments.)
    ))

    $(BEST_PRACTICE Even though the order of evaluation is well defined, writing code that
    depends on it is rarely recommended.)

$(H2 $(LEGACY_LNAME2 Expression, expression, Expressions))

$(GRAMMAR
$(GNAME Expression):
    $(I CommaExpression)

$(GNAME CommaExpression):
    $(GLINK AssignExpression)
    $(GLINK AssignExpression) $(D ,) $(I CommaExpression)
)

    $(P The left operand of the $(D ,) is evaluated, then the right operand
        is evaluated. The type of the expression is the type of the right
        operand, and the result is the result of the right operand.
        Using the result of comma expressions isn't allowed.
    )

$(H2 $(LNAME2 assign_expressions, Assign Expressions))

$(GRAMMAR
$(GNAME AssignExpression):
    $(GLINK ConditionalExpression)
    $(GLINK ConditionalExpression) $(D =) $(I AssignExpression)
    $(GLINK ConditionalExpression) $(D +=) $(I AssignExpression)
    $(GLINK ConditionalExpression) $(D -=) $(I AssignExpression)
    $(GLINK ConditionalExpression) $(D *=) $(I AssignExpression)
    $(GLINK ConditionalExpression) $(D /=) $(I AssignExpression)
    $(GLINK ConditionalExpression) $(D %=) $(I AssignExpression)
    $(GLINK ConditionalExpression) $(D &=) $(I AssignExpression)
    $(GLINK ConditionalExpression) $(D |=) $(I AssignExpression)
    $(GLINK ConditionalExpression) $(D ^=) $(I AssignExpression)
    $(GLINK ConditionalExpression) $(D ~=) $(I AssignExpression)
    $(GLINK ConditionalExpression) $(D <)$(D <)$(D =) $(I AssignExpression)
    $(GLINK ConditionalExpression) $(D >>=) $(I AssignExpression)
    $(GLINK ConditionalExpression) $(D >>>=) $(I AssignExpression)
    $(GLINK ConditionalExpression) $(D ^^=) $(I AssignExpression)
)

    $(P For all assign expressions, the left operand must be a modifiable
    lvalue. The type of the assign expression is the type of the left
    operand, and the value is the value of the left operand after assignment
    occurs. The resulting expression is a modifiable lvalue.
    )

    $(UNDEFINED_BEHAVIOR
    $(OL
    $(LI if the lvalue and rvalue have partially overlapping storage)
    $(LI if the lvalue and rvalue's storage overlaps exactly but the types are different)
    ))

$(H3 $(LNAME2 simple_assignment_expressions, Simple Assignment Expression))

    $(P If the operator is $(D =) then it is simple assignment.
    The right operand is implicitly converted to the type of the
    left operand, and assigned to it.)

    $(P If the left and right operands are of the same struct type, and the struct
    type has a $(GLINK2 struct, Postblit), then the copy operation is
    as described in $(DDSUBLINK spec/struct, struct-postblit, Struct Postblit).
    )

    $(P If the lvalue is the `.length` property of a dynamic array, the behavior is
    as described in $(DDSUBLINK spec/array, resize, Setting Dynamic Array Length).
    )

    $(P If the lvalue is a static array or a slice, the behavior is as
    described in $(DDSUBLINK spec/array, array-copying, Array Copying) and
    $(DDSUBLINK spec/array, array-setting, Array Setting).
    )

    $(P If the lvalue is a user-defined property, the behavior is as
    described in $(DDSUBLINK spec/function, property-functions, Property Functions).
    )

$(H3 $(LNAME2 assignment_operator_expressions, Assignment Operator Expressions))

    $(P For arguments of built-in types, assignment operator expressions such as)

        --------------
        a op= b
        --------------

        are semantically equivalent to:

        --------------
        a = cast(typeof(a))(a op b)
        --------------

    except that

    $(UL
        $(LI operand $(D a) is only evaluated once,)
        $(LI overloading $(I op) uses a different function than overloading $(I op)= does, and)
        $(LI the left operand of $(D >>>=) does not undergo integral promotions before shifting.)
    )

    $(P For user-defined types, assignment operator expressions are overloaded separately from
        the binary operator. Still the left operand must be an lvalue.
    )

$(H2 $(LNAME2 conditional_expressions, Conditional Expressions))

$(GRAMMAR
$(GNAME ConditionalExpression):
    $(GLINK OrOrExpression)
    $(GLINK OrOrExpression) $(D ?) $(GLINK Expression) $(D :) $(I ConditionalExpression)
)

    $(P The first expression is converted to $(D bool), and is evaluated.
    )

    $(P If it is $(D true), then the second expression is evaluated, and
        its result is the result of the conditional expression.
    )

    $(P If it is $(D false), then the third expression is evaluated, and
        its result is the result of the conditional expression.
    )

    $(P If either the second or third expressions are of type $(D void),
        then the resulting type is $(D void). Otherwise, the second and third
        expressions are implicitly converted to a common type which becomes
        the result type of the conditional expression.
    )

$(H2 $(LNAME2 oror_expressions, OrOr Expressions))

$(GRAMMAR
$(GNAME OrOrExpression):
    $(GLINK AndAndExpression)
    $(I OrOrExpression) $(D ||) $(GLINK AndAndExpression)
)

    $(P The result type of an $(I OrOrExpression) is $(D bool), unless the right operand
        has type $(D void), when the result is type $(D void).
    )

    $(P The $(I OrOrExpression) evaluates its left operand.
    )

    $(P If the left operand, converted to type $(D bool), evaluates to
        $(D true), then the right operand is not evaluated. If the result type of
        the $(I OrOrExpression) is $(D bool) then the result of the
        expression is $(D true).
    )

    $(P If the left operand is $(D false), then the right
        operand is evaluated.
        If the result type of
        the $(I OrOrExpression) is $(D bool) then the result of the
        expression is the right operand converted to type $(D bool).
    )

$(H2 $(LNAME2 andand_expressions, AndAnd Expressions))

$(GRAMMAR
$(GNAME AndAndExpression):
    $(GLINK OrExpression)
    $(I AndAndExpression) $(CODE_AMP)$(CODE_AMP) $(GLINK OrExpression)
)

    $(P The result type of an $(I AndAndExpression) is $(D bool), unless the right operand
        has type $(D void), when the result is type $(D void).
    )

    $(P The $(I AndAndExpression) evaluates its left operand.
    )

    $(P If the left operand, converted to type $(D bool), evaluates to
        $(D false), then the right operand is not evaluated. If the result type of
        the $(I AndAndExpression) is $(D bool) then the result of the
        expression is $(D false).
    )

    $(P If the left operand is $(D true), then the right
        operand is evaluated.
        If the result type of
        the $(I AndAndExpression) is $(D bool) then the result of the
        expression is the right operand converted to type $(D bool).
    )

$(H2 $(LNAME2 bitwise_expressions, Bitwise Expressions))

    $(P Bit wise expressions perform a bitwise operation on their operands.
        Their operands must be integral types.
        First, the default integral promotions are done. Then, the bitwise
        operation is done.
    )

$(H3 $(LNAME2 or_expressions, Or Expressions))

$(GRAMMAR
$(GNAME OrExpression):
    $(GLINK XorExpression)
    $(I OrExpression) $(D |) $(GLINK XorExpression)
)

    $(P The operands are OR'd together.)

$(H3 $(LNAME2 xor_expressions, Xor Expressions))

$(GRAMMAR
$(GNAME XorExpression):
    $(GLINK AndExpression)
    $(I XorExpression) $(D ^) $(GLINK AndExpression)
)

    $(P The operands are XOR'd together.)

$(H3 $(LNAME2 and_expressions, And Expressions))

$(GRAMMAR
$(GNAME AndExpression):
    $(GLINK CmpExpression)
    $(I AndExpression) $(D &) $(GLINK CmpExpression)
)

    $(P The operands are AND'd together.)

$(H2 $(LNAME2 compare_expressions, Compare Expressions))

$(GRAMMAR
$(GNAME CmpExpression):
    $(GLINK ShiftExpression)
    $(GLINK EqualExpression)
    $(GLINK IdentityExpression)
    $(GLINK RelExpression)
    $(GLINK InExpression)
)

$(H2 $(LNAME2 equality_expressions, Equality Expressions))

$(GRAMMAR
$(GNAME EqualExpression):
    $(GLINK ShiftExpression) $(D ==) $(GLINK ShiftExpression)
    $(GLINK ShiftExpression) $(D !=) $(GLINK ShiftExpression)
)

    $(P Equality expressions compare the two operands for equality ($(D ==))
        or inequality ($(D !=)).
        The type of the result is $(D bool). The operands
        go through the usual conversions to bring them to a common type before
        comparison.
    )

    $(P If they are integral values or pointers, equality
        is defined as the bit pattern of the type matches exactly.
    )

    $(P Equality for floating point types is more complicated. $(D -0) and
        $(D +0) compare as equal. If either or both operands are NAN, then
        both the $(D ==) returns false and $(D !=) returns $(D true). Otherwise, the bit
        patterns are compared for equality.
    )

    $(P For complex numbers, equality is defined as equivalent to:)

        ---
        x.re == y.re && x.im == y.im
        ---

        and inequality is defined as equivalent to:

        ---
        x.re != y.re || x.im != y.im
        ---

    $(P Equality for struct objects means the logical product of all equality
        results of the corresponding object fields.
        If all struct fields use bitwise equality, the whole struct equality
        could be optimized to one memory comparison operation (the existence of
        alignment holes in the objects is accounted for, usually by setting them
        all to 0 upon initialization).
    )

    $(P For class and struct objects, the expression $(D (a == b))
        is rewritten as
        $(D a.opEquals(b)), and $(D (a != b)) is rewritten as
        $(D !a.opEquals(b)).
    )

    $(P For class objects, the $(D ==) and $(D !=)
        operators are intended to compare the contents of the objects,
        however an appropriate $(D opEquals) override must be defined for this to work.
        The default $(D opEquals) provided by the root $(D Object) class is
        equivalent to the $(D is) operator.
        Comparing against $(D null) is invalid, as $(D null) has no contents.
        Use the $(D is) and $(D !is) operators instead.)

        ---
        class C;
        C c;
        if (c == null)  // error
            ...
        if (c is null)  // ok
            ...
        ---

    $(P For static and dynamic arrays, equality is defined as the
        lengths of the arrays
        matching, and all the elements are equal.
    )

$(H3 $(LNAME2 identity_expressions, Identity Expressions))

$(GRAMMAR
$(GNAME IdentityExpression):
    $(GLINK ShiftExpression) $(D is) $(GLINK ShiftExpression)
    $(GLINK ShiftExpression) $(D !is) $(GLINK ShiftExpression)
)

    $(P The $(D is) compares for identity.
        To compare for nonidentity, use $(D e1 !is e2).
        The type of the result is $(D bool). The operands
        go through the usual conversions to bring them to a common type before
        comparison.
    )

    $(P For class objects, identity is defined as the object references
        are for the same object. Null class objects can be compared with
        $(D is).
    )

    $(P For struct objects and floating point values, identity is defined as the
        bits in the operands being identical.
    )

    $(P For static and dynamic arrays, identity is defined as referring
        to the same array elements and the same number of elements.
    )

    $(P For other operand types, identity is defined as being the same
        as equality.
    )

    $(P The identity operator $(D is) cannot be overloaded.
    )

$(H2 $(LNAME2 relation_expressions, Relational Expressions))

$(GRAMMAR
$(GNAME RelExpression):
    $(GLINK ShiftExpression) $(D <) $(GLINK ShiftExpression)
    $(GLINK ShiftExpression) $(D <)$(D =) $(GLINK ShiftExpression)
    $(GLINK ShiftExpression) $(D >) $(GLINK ShiftExpression)
    $(GLINK ShiftExpression) $(D >=) $(GLINK ShiftExpression)
)

    $(P First, the integral promotions are done on the operands.
        The result type of a relational expression is $(D bool).
    )

    $(P For class objects, the result of Object.opCmp() forms the left
        operand, and 0 forms the right operand. The result of the
        relational expression (o1 op o2) is:)

        ---
        (o1.opCmp(o2) op 0)
        ---

    $(P It is an error to compare objects if one is $(D null).)

    $(P For static and dynamic arrays, the result of the relational
        op is the result of the operator applied to the first non-equal
        element of the array. If two arrays compare equal, but are of
        different lengths, the shorter array compares as "less" than the
        longer array.
    )

$(H3 $(LNAME2 integer_comparisons, Integer comparisons))

    $(P Integer comparisons happen when both operands are integral
        types.
    )

    $(TABLE2 Integer comparison operators,
        $(THEAD Operator, Relation)
        $(TROW $(D <), less)
        $(TROW $(D >), greater)
        $(TROW $(D <)$(D =), less or equal)
        $(TROW $(D >=), greater or equal)
        $(TROW $(D ==), equal)
        $(TROW $(D !=), not equal)
    )

    $(P It is an error to have one operand be signed and the other
        unsigned for a $(D <), $(D <)$(D =), $(D >) or
        $(D >)$(D =) expression.
        Use casts to make both operands signed or both operands unsigned.
    )

$(H3 $(LEGACY_LNAME2 floating_point_comparisons, floating-point-comparisons, Floating point comparisons))

    $(P If one or both operands are floating point, then a floating
        point comparison is performed.
    )

    $(P A relational operator can have `NaN` operands.
        If either or both operands is `NaN`, the floating point
        comparison operation returns as follows:)

        $(TABLE2 Floating point comparison operators,
        $(THEAD Operator, Relation, Returns)
        $(TROW $(D <),$(ARGS less), `false`)
        $(TROW $(D >),$(ARGS greater), `false`)
        $(TROW $(D <)$(D =),$(ARGS less or equal), `false`)
        $(TROW $(D >=),$(ARGS greater or equal), `false`)
        $(TROW $(D ==),equal, `false`)
        $(TROW $(D !=),$(ARGS unordered, less, or greater), `true`)
        )

$(H3 $(LEGACY_LNAME2 class_comparisons, class-comparisons, Class comparisons))

    $(P For class objects, the relational
        operators compare the
        contents of the objects. Therefore, comparing against
        $(CODE null) is invalid, as $(CODE null) has no contents.)

        ---
        class C;
        C c;
        if (c < null)  // error
            ...
        ---

$(H2 $(LNAME2 in_expressions, In Expressions))

$(GRAMMAR
$(GNAME InExpression):
    $(GLINK ShiftExpression) $(D in) $(GLINK ShiftExpression)
    $(GLINK ShiftExpression) $(D !in) $(GLINK ShiftExpression)
)

$(P An associative array can be tested to see if an element is in the array:)

        -------------
        int foo[char[]];
        ...
        if ("hello" in foo)
            ...
        -------------

    $(P The $(D in) expression has the same precedence as the
        relational expressions $(D <), $(D <)$(D =),
        etc.
        The return value of the $(I InExpression) is $(D null)
        if the element is not in the array;
        if it is in the array it is a pointer to the element.
    )

    $(P The $(D !in) expression is the logical negation of the $(D in)
        operation.
    )

$(H2 $(LNAME2 shift_expressions, Shift Expressions))

$(GRAMMAR
$(GNAME ShiftExpression):
    $(GLINK AddExpression)
    $(I ShiftExpression) $(D <)$(D <) $(GLINK AddExpression)
    $(I ShiftExpression) $(D >)$(D >) $(GLINK AddExpression)
    $(I ShiftExpression) $(D >)$(D >)$(D >) $(GLINK AddExpression)
)

    $(P The operands must be integral types, and undergo the usual integral
        promotions. The result type is the type of the left operand after
        the promotions. The result value is the result of shifting the bits
        by the right operand's value.
    )

    $(P $(D <)$(D <) is a left shift.
        $(D >)$(D >) is a signed right shift.
        $(D >)$(D >)$(D >) is an unsigned right shift.
    )

    $(P It's illegal to shift by the same or more bits than the size of the
        quantity being shifted:)

        -------------
        int c;
        auto x = c << 33;        // error
        -------------

$(H2 $(LNAME2 add_expressions, Add Expressions))

$(GRAMMAR
$(GNAME AddExpression):
    $(GLINK MulExpression)
    $(I AddExpression) $(D +) $(GLINK MulExpression)
    $(I AddExpression) $(D -) $(GLINK MulExpression)
    $(GLINK CatExpression)
)

    $(P If the operands are of integral types, they undergo integral
        promotions, and then are brought to a common type using the
        usual arithmetic conversions.
    )

    $(P If either operand is a floating point type, the other is implicitly
        converted to floating point and they are brought to a common type
        via the usual arithmetic conversions.
    )

    $(P If the operator is $(D +) or $(D -), and
        the first operand is a pointer, and the second is an integral type,
        the resulting type is the type of the first operand, and the resulting
        value is the pointer plus (or minus) the second operand multiplied by
        the size of the type pointed to by the first operand.
    )

    $(P If the second operand is a pointer, and the first is an integral type,
        and the operator is $(D +),
        the operands are reversed and the pointer arithmetic just described
        is applied.
    )

    $(P If both operands are pointers, and the operator is $(D +),
        then it is illegal.
    )

    $(P If both operands are pointers, and the operator is $(D -),
        the pointers are subtracted and the
        result is divided by the size of the type pointed to by the
        operands. It is an error if the pointers point to different types.
        The type of the result is $(D ptrdiff_t).
    )

    $(P If both operands are of integral types and an overflow or underflow
        occurs in the computation, wrapping will happen. That is,
        $(D uint.max + 1 == uint.min) and $(D uint.min - 1 == uint.max).
    )

    $(P Add expressions for floating point operands are not associative.
    )

$(H2 $(LNAME2 cat_expressions, Cat Expressions))

$(GRAMMAR
$(GNAME CatExpression):
    $(GLINK AddExpression) $(D ~) $(GLINK MulExpression)
)

    $(P A $(I CatExpression) concatenates arrays, producing
        a dynamic array with the result. The arrays must be
        arrays of the same element type. If one operand is an array
        and the other is of that array's element type, that element
        is converted to an array of length 1 of that element,
        and then the concatenation is performed.
    )

$(H2 $(LNAME2 mul_expressions, Mul Expressions))

$(GRAMMAR
$(GNAME MulExpression):
    $(GLINK UnaryExpression)
    $(I MulExpression) $(D *) $(GLINK UnaryExpression)
    $(I MulExpression) $(D /) $(GLINK UnaryExpression)
    $(I MulExpression) $(D %) $(GLINK UnaryExpression)
)

    $(P The operands must be arithmetic types. They undergo integral
        promotions, and then are brought to a common type using the
        usual arithmetic conversions.
    )

    $(P For integral operands, the $(D *), $(D /), and $(D %)
        correspond to multiply, divide, and modulus operations.
        For multiply, overflows are ignored and simply chopped to fit
        into the integral type.
    )

    $(P For integral operands of the $(D /) and $(D %) operators,
        the quotient rounds towards zero and the remainder has the
        same sign as the dividend.
        If the divisor is zero, an Exception is thrown.
    )

    $(P For floating point operands, the * and / operations correspond
        to the IEEE 754 floating point equivalents. % is not the same as
        the IEEE 754 remainder. For example, 15.0 % 10.0 == 5.0, whereas
        for IEEE 754, remainder(15.0,10.0) == -5.0.
    )

    $(P Mul expressions for floating point operands are not associative.
    )

$(H2 $(LEGACY_LNAME2 UnaryExpression, unary-expression, Unary Expressions))

$(GRAMMAR
$(GNAME UnaryExpression):
    $(CODE_AMP) $(I UnaryExpression)
    $(D ++) $(I UnaryExpression)
    $(D --) $(I UnaryExpression)
    $(D *) $(I UnaryExpression)
    $(D -) $(I UnaryExpression)
    $(D +) $(I UnaryExpression)
    $(D !) $(I UnaryExpression)
    $(GLINK ComplementExpression)
    $(D $(LPAREN)) $(GLINK2 declaration, Type) $(D $(RPAREN) .) $(IDENTIFIER)
    $(D $(LPAREN)) $(GLINK2 declaration, Type) $(D $(RPAREN) .) $(GLINK2 template, TemplateInstance)
    $(GLINK DeleteExpression)
    $(GLINK CastExpression)
    $(GLINK PowExpression)
)

$(H3 $(LNAME2 complement_expressions, Complement Expressions))

$(GRAMMAR
$(GNAME ComplementExpression):
    $(D ~) $(GLINK UnaryExpression)
)

    $(P $(I ComplementExpression)s work on integral types (except $(D bool)).
        All the bits in the value are complemented.
    )

    $(P $(B Note:) the usual integral promotions are not performed
        prior to the complement operation.
    )

$(H3 $(LNAME2 new_expressions, New Expressions))

$(GRAMMAR
$(GNAME NewExpression):
    $(D new) $(I AllocatorArguments)$(OPT) $(GLINK2 declaration, Type)
    $(GLINK NewExpressionWithArgs)

$(GNAME NewExpressionWithArgs):
    $(D new) $(I AllocatorArguments)$(OPT) $(GLINK2 declaration, Type) $(D [) $(GLINK AssignExpression) $(D ])
    $(D new) $(I AllocatorArguments)$(OPT) $(GLINK2 declaration, Type) $(D $(LPAREN)) $(GLINK ArgumentList)$(OPT) $(D $(RPAREN))
    $(GLINK2 class, NewAnonClassExpression)

$(GNAME AllocatorArguments):
    $(D $(LPAREN)) $(GLINK ArgumentList)$(OPT) $(D $(RPAREN))

$(GNAME ArgumentList):
    $(GLINK AssignExpression)
    $(GLINK AssignExpression) $(D ,)
    $(GLINK AssignExpression) $(D ,) $(I ArgumentList)
)

    $(P $(I NewExpression)s are used to allocate memory on the garbage
        collected heap (default) or using a class or struct specific allocator.
    )

    $(P To allocate multidimensional arrays, the declaration reads
        in the same order as the prefix array declaration order.)

        -------------
        char[][] foo;   // dynamic array of strings
        ...
        foo = new char[][30]; // allocate array of 30 strings
        -------------

    $(P The above allocation can also be written as:)

        -------------
        foo = new char[][](30); // allocate array of 30 strings
        -------------

    $(P To allocate the nested arrays, multiple arguments can be used:)

        ---------------
        int[][][] bar;
        ...
        bar = new int[][][](5, 20, 30);
        ---------------

    The code above is equivalent to:

        ----------
        bar = new int[][][5];
        foreach (ref a; bar)
        {
            a = new int[][20];
            foreach (ref b; a)
            {
                b = new int[30];
            }
        }
        -----------

    $(P If there is a $(D new $(LPAREN)) $(GLINK ArgumentList) $(D $(RPAREN)),
        then
        those arguments are passed to the class or struct specific
        $(DDSUBLINK spec/class, allocators, allocator function) after the size argument.
    )

    $(P If a $(I NewExpression) is used as an initializer for
        a function local variable with $(D scope) storage class,
        and the $(GLINK ArgumentList) to $(D new) is empty, then
        the instance is allocated on the stack rather than the heap
        or using the class specific allocator.
    )

$(H3 $(LNAME2 delete_expressions, Delete Expressions))

$(GRAMMAR
$(GNAME DeleteExpression):
    $(D delete) $(GLINK UnaryExpression)
)
    $(P If the $(I UnaryExpression) is a class object reference, and
        there is a destructor for that class, the destructor
        is called for that object instance.
    )

    $(P Next, if the $(I UnaryExpression) is a class object reference, or
        a pointer to a struct instance, and the class or struct
        has overloaded operator delete, then that operator delete is called
        for that class object instance or struct instance.
    )

    $(P Otherwise, the garbage collector is called to immediately free the
        memory allocated for the class instance or struct instance.
        If the garbage collector was not used to allocate the memory for
        the instance, undefined behavior will result.
    )

    $(P If the $(I UnaryExpression) is a pointer or a dynamic array,
        the garbage collector is called to immediately release the
        memory.
        If the garbage collector was not used to allocate the memory for
        the instance, undefined behavior will result.
    )

    $(P The pointer, dynamic array, or reference is set to $(D null)
        after the delete is performed.
        Any attempt to reference the data after the deletion via another
        reference to it will result in undefined behavior.
    )

    $(P If $(I UnaryExpression) is a variable allocated
        on the stack, the class destructor (if any) is called for that
        instance. Neither the garbage collector nor any class deallocator
        is called.
    )

$(H3 $(LNAME2 cast_expressions, Cast Expressions))

$(GRAMMAR
$(GNAME CastExpression):
    $(D cast $(LPAREN)) $(GLINK2 declaration, Type) $(D $(RPAREN)) $(GLINK UnaryExpression)
    $(D cast $(LPAREN)) $(GLINK2 declaration, TypeCtors)$(OPT) $(D $(RPAREN)) $(GLINK UnaryExpression)
)

    $(P A $(I CastExpression) converts the $(I UnaryExpression)
        to $(GLINK2 declaration, Type).)

        -------------
        cast(foo) -p; // cast (-p) to type foo
        (foo) - p;      // subtract p from foo
        -------------

    $(P Any casting of a class reference to a
        derived class reference is done with a runtime check to make sure it
        really is a downcast. $(D null) is the result if it isn't.
    )

        -------------
        class A { ... }
        class B : A { ... }

        void test(A a, B b)
        {
            B bx = a;         // error, need cast
            B bx = cast(B) a; // bx is null if a is not a B
            A ax = b;         // no cast needed
            A ax = cast(A) b; // no runtime check needed for upcast
        }
        -------------

    $(P In order to determine if an object $(D o) is an instance of
        a class $(D B) use a cast:)

        -------------
        if (cast(B) o)
        {
            // o is an instance of B
        }
        else
        {
            // o is not an instance of B
        }
        -------------

    $(P Casting a pointer type to and from a class type is done as a type paint
        (i.e. a reinterpret cast).
    )

    $(P Casting a dynamic array to another dynamic array is done only if the
        array lengths multiplied by the element sizes match. The cast is done
        as a type paint, with the array length adjusted to match any change in
        element size. If there's not a match, a runtime error is generated.)

        ---
        import std.stdio;

        int main()
        {
            byte[] a = [1,2,3];
            auto b = cast(int[])a; // runtime array cast misalignment

            int[] c = [1, 2, 3];
            auto d = cast(byte[])c; // ok
            // prints:
            // [1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0]
            writeln(d);
            return 0;
        }
        ---

    $(P Casting a floating point literal from one type to another
        changes its type, but internally it is retained at full
        precision for the purposes of constant folding.)

        ---
        void test()
        {
            real a = 3.40483L;
            real b;
            b = 3.40483;     // literal is not truncated to double precision
            assert(a == b);
            assert(a == 3.40483);
            assert(a == 3.40483L);
            assert(a == 3.40483F);
            double d = 3.40483; // truncate literal when assigned to variable
            assert(d != a);     // so it is no longer the same
            const double x = 3.40483; // assignment to const is not
            assert(x == a);     // truncated if the initializer is visible
        }
        ---

    $(P Casting a floating point value to an integral type is the equivalent
        of converting to an integer using truncation.)

        ---
        void main()
        {
            int a = cast(int) 0.8f;
            assert(a == 0);
            long b = cast(long) 1.5;
            assert(b == 1L);
            long c = cast(long) -1.5;
            assert(c == -1);
        }
        ---

    $(P Casting a value $(I v) to a struct $(I S), when value is not a struct
        of the same type, is equivalent to:)

        ---
        S(v)
        ---

    $(P Casting to a $(GLINK CastQual) replaces the qualifiers to the type of
        the $(GLINK UnaryExpression).)

        ---
        shared int x;
        assert(is(typeof(cast(const)x) == const int));
        ---

    $(P Casting with no $(GLINK Type) or $(GLINK CastQual) removes
        any top level $(D const), $(D immutable), $(D shared) or $(D inout)
        type modifiers from the type
        of the $(GLINK UnaryExpression).)

        ---
        shared int x;
        assert(is(typeof(cast()x) == int));
        ---

    $(P Casting an expression to $(D void) type is allowed to mark that
        the result is unused. On $(GLINK2 statement, ExpressionStatement),
        it could be used properly to avoid "has no effect" error.)

        ----
        void foo(lazy void exp) {}
        void main()
        {
            foo(10);            // NG - has no effect in expression '10'
            foo(cast(void)10);  // OK
        }
        ----

$(H2 $(LNAME2 pow_expressions, Pow Expressions))

$(GRAMMAR
$(GNAME PowExpression):
    $(GLINK PostfixExpression)
    $(GLINK PostfixExpression) $(D ^^) $(GLINK UnaryExpression)
)

    $(P $(I PowExpression) raises its left operand to the power of its
        right operand.
    )

$(H2 $(LNAME2 postfix_expressions, Postfix Expressions))

$(GRAMMAR
$(GNAME PostfixExpression):
    $(GLINK PrimaryExpression)
    $(I PostfixExpression) $(D .) $(IDENTIFIER)
    $(I PostfixExpression) $(D .) $(GLINK2 template, TemplateInstance)
    $(I PostfixExpression) $(D .) $(GLINK NewExpression)
    $(I PostfixExpression) $(D ++)
    $(I PostfixExpression) $(D --)
    $(I PostfixExpression) $(D $(LPAREN)) $(GLINK ArgumentList)$(OPT) $(D $(RPAREN))
    $(GLINK2 declaration, TypeCtors)$(OPT) $(GLINK2 declaration, BasicType) $(D $(LPAREN)) $(GLINK ArgumentList)$(OPT) $(D $(RPAREN))
    $(GLINK IndexExpression)
    $(GLINK SliceExpression)
)

$(H2 $(LNAME2 index_expressions, Index Expressions))

$(GRAMMAR
$(GNAME IndexExpression):
    $(GLINK PostfixExpression) $(D [) $(GLINK ArgumentList) $(D ])
)

$(P $(I PostfixExpression) is evaluated. If $(I PostfixExpression) is an
expression of type static array or dynamic array, the symbol $(DOLLAR) is set to
be the number of elements in the array. If $(I PostfixExpression) is a $(I
ValueSeq), the symbol $(DOLLAR) is set to be the number of elements
in the sequence. A new declaration scope is created for the evaluation of the
$(GLINK ArgumentList) and $(DOLLAR) appears in that scope only.)

    $(P If $(I PostfixExpression) is a $(I ValueSeq),
        then the $(GLINK ArgumentList) must consist of only one argument,
        and that must be statically evaluatable to an integral constant.
        That integral constant $(I n) then selects the $(I n)th
        expression in the $(I ValueSeq), which is the result
        of the $(I IndexExpression).
        It is an error if $(I n) is out of bounds of the $(I ValueSeq).
    )

$(H2 $(LNAME2 slice_expressions, Slice Expressions))

$(GRAMMAR
$(GNAME SliceExpression):
    $(GLINK PostfixExpression) $(D [ ])
    $(GLINK PostfixExpression) $(D [) $(I Slice) $(D ,)$(OPT) $(D ])
$(GNAME Slice):
    $(GLINK AssignExpression)
    $(GLINK AssignExpression) $(D ,) $(I Slice)
    $(GLINK AssignExpression) $(D ..) $(GLINK AssignExpression)
    $(GLINK AssignExpression) $(D ..) $(GLINK AssignExpression) $(D ,) $(I Slice)
)

    $(P $(I PostfixExpression) is evaluated.
        if $(I PostfixExpression) is an expression of type
        static array or dynamic array, the special variable $(DOLLAR)
        is declared and set to be the length of the array.
        A new declaration scope is created for the evaluation of the
        $(GLINK AssignExpression)..$(GLINK AssignExpression)
        and $(DOLLAR) appears in that scope only.
    )

    $(P The first $(I AssignExpression) is taken to be the inclusive
        lower bound
        of the slice, and the second $(I AssignExpression) is the
        exclusive upper bound.
        The result of the expression is a slice of the $(I PostfixExpression)
        array.
    )

    $(P If the $(D [ ]) form is used, the slice is of the entire
        array.
    )

    $(P The type of the slice is a dynamic array of the element
        type of the $(I PostfixExpression).
    )

    $(P A $(I SliceExpression) is not a modifiable lvalue.)

    $(P If the slice bounds can be known at compile time, the slice expression
    is implicitly convertible to an lvalue of static array. For example:)

        -------------
        arr[a .. b]     // typed T[]
        -------------

        If both $(CODE a) and $(CODE b) are integers (may be constant-folded),
        the slice expression can be converted to a static array type
        $(D T[b - a]).

        -------------
        void foo(int[2] a)
        {
            assert(a == [2, 3]);
        }
        void bar(ref int[2] a)
        {
            assert(a == [2, 3]);
            a[0] = 4;
            a[1] = 5;
            assert(a == [4, 5]);
        }
        void baz(int[3] a) {}

        void main()
        {
            int[] arr = [1, 2, 3];

            foo(arr[1 .. 3]);
            assert(arr == [1, 2, 3]);

            bar(arr[1 .. 3]);
            assert(arr == [1, 4, 5]);

          //baz(arr[1 .. 3]); // cannot match length
        }
        -------------

$(P The following forms of slice expression can be convertible to a static array
type:)

        $(DL
        $(DT $(D e)) $(DD An expression that contains no side effects.)
        $(DT $(D a), $(D b)) $(DD Integers (that may be constant-folded).)
        )

        $(TABLE2 Computing array lengths during compilation,
        $(THEAD Form, The length calculated at compile time)
        $(TROW $(D arr[]), The compile time length of $(D arr) if it's known.)
        $(TROW $(D arr[a .. b]),               $(D b - a))
        $(TROW $(D arr[e-a .. e]),   $(D a))
        $(TROW $(D arr[e .. e+b]),   $(D b))
        $(TROW $(D arr[e-a .. e+b]), $(D a + b))
        $(TROW $(D arr[e+a .. e+b]), $(D b - a) $(I if) $(D a <= b))
        $(TROW $(D arr[e-a .. e-b]), $(D a - b) $(I if) $(D a >= b))
        )

    $(P If $(I PostfixExpression) is a $(I ValueSeq), then
        the result of the slice is a new $(I ValueSeq) formed
        from the upper and lower bounds, which must statically evaluate
        to integral constants.
        It is an error if those
        bounds are out of range.
    )

$(H2 $(LNAME2 primary_expressions, Primary Expressions))

$(GRAMMAR
$(GNAME PrimaryExpression):
    $(IDENTIFIER)
    $(D .) $(IDENTIFIER)
    $(GLINK2 template, TemplateInstance)
    $(D .) $(GLINK2 template, TemplateInstance)
    $(RELATIVE_LINK2 this, $(D this))
    $(RELATIVE_LINK2 super, $(D super))
    $(RELATIVE_LINK2 null, $(D null))
    $(D true)
    $(D false)
    $(D $)
    $(GLINK2 lex, IntegerLiteral)
    $(GLINK2 lex, FloatLiteral)
    $(GLINK CharacterLiteral)
    $(GLINK StringLiterals)
    $(GLINK ArrayLiteral)
    $(GLINK AssocArrayLiteral)
    $(GLINK FunctionLiteral)
    $(GLINK AssertExpression)
    $(GLINK MixinExpression)
    $(GLINK ImportExpression)
    $(GLINK NewExpressionWithArgs)
    $(GLINK2 declaration, BasicTypeX) $(D .) $(IDENTIFIER)
    $(GLINK2 declaration, BasicTypeX) $(D $(LPAREN)) $(GLINK ArgumentList)$(OPT) $(D $(RPAREN))
    $(GLINK2 declaration, TypeCtor) $(D $(LPAREN)) $(GLINK Type) $(D $(RPAREN)) $(D .) $(IDENTIFIER)
    $(GLINK2 declaration, TypeCtor) $(D $(LPAREN)) $(GLINK Type) $(D $(RPAREN)) $(D $(LPAREN)) $(GLINK ArgumentList)$(OPT) $(D $(RPAREN))
    $(GLINK2 declaration, Typeof)
    $(GLINK TypeidExpression)
    $(GLINK IsExpression)
    $(D $(LPAREN)) $(GLINK Expression) $(D $(RPAREN))
    $(GLINK2 traits, TraitsExpression)
    $(GLINK2 traits, SpecialKeyword)
)

$(H3 $(LNAME2 identifier, .Identifier))

    $(P $(IDENTIFIER) is looked up at module scope, rather than the current
        lexically nested scope.
    )

$(H3 $(LNAME2 this, this))

    $(P Within a non-static member function, $(D this) resolves to
        a reference to the object for which the function was called.
        If the object is an instance of a struct, $(D this) will
        be a pointer to that instance.
        If a member function is called with an explicit reference
        to $(D typeof(this)), a non-virtual call is made:)

        -------------
        class A
        {
            char get() { return 'A'; }

            char foo() { return typeof(this).get(); }
            char bar() { return this.get(); }
        }

        class B : A
        {
            override char get() { return 'B'; }
        }

        void main()
        {
            B b = new B();

            assert(b.foo() == 'A');
            assert(b.bar() == 'B');
        }
        -------------

    $(P Assignment to $(D this) is not allowed.)

$(H3 $(LNAME2 super, super))

    $(P $(D super) is identical to $(D this), except that it is
        cast to $(D this)'s base class.
        It is an error if there is no base class.
        It is an error to use $(D super) within a struct member function.
        (Only class $(D Object) has no base class.)
        If a member function is called with an explicit reference
        to $(D super), a non-virtual call is made.
    )

    $(P Assignment to $(D super) is not allowed.)

$(H3 $(LNAME2 null, null))

    $(P $(D null) represents the null value for
        pointers, pointers to functions, delegates,
        dynamic arrays, associative arrays,
        and class objects.
        If it has not already been cast to a type,
        it is given the singular type $(D typeof(null)) and it is an exact conversion
        to convert it to the null value for pointers, pointers to
        functions, delegates, etc.
        After it is cast to a type, such conversions are implicit,
        but no longer exact.
    )

$(H3 $(LNAME2 true_false, true, false))

    $(P These are of type $(D bool) and when cast to another integral
        type become the values 1 and 0,
        respectively.
    )

$(H3 $(LEGACY_LNAME2 CharacterLiteral, character-literal, Character Literals))

    $(P Character literals are single characters and resolve to one
        of type $(D char), $(D wchar), or $(D dchar).
        If the literal is a $(D \u) escape sequence, it resolves to type $(D wchar).
        If the literal is a $(D \U) escape sequence, it resolves to type $(D dchar).
        Otherwise, it resolves to the type with the smallest size it
        will fit into.
    )

$(H3 $(LNAME2 string_literals, String Literals))

$(GRAMMAR
$(GNAME StringLiterals):
    $(GLINK2 lex, StringLiteral)
    $(I StringLiterals) $(GLINK2 lex, StringLiteral)
)

    $(P String literals can implicitly convert to any
        of the following types, they have equal weight:
    )

    $(TABLE
        $(TROW $(D immutable(char)*))
        $(TROW $(D immutable(wchar)*))
        $(TROW $(D immutable(dchar)*))
        $(TROW $(D immutable(char)[]))
        $(TROW $(D immutable(wchar)[]))
        $(TROW $(D immutable(dchar)[]))
    )

    $(P By default, a string literal is typed as a dynamic array, but the element
        count is known at compile time. So all string literals can be
        implicitly converted to static array types.)

        -------------
        void foo(char[2] a)
        {
            assert(a == "bc");
        }
        void bar(ref const char[2] a)
        {
            assert(a == "bc");
        }
        void baz(const char[3] a) {}

        void main()
        {
            string str = "abc";
            foo(str[1 .. 3]);
            bar(str[1 .. 3]);
          //baz(str[1 .. 3]); // cannot match length
        }
        -------------

    $(P String literals have a 0 appended to them, which makes
        them easy to pass to C or C++ functions expecting a $(CODE const char*)
        string.
        The 0 is not included in the $(CODE .length) property of the
        string literal.
    )

$(H3 $(LNAME2 array_literals, Array Literals))

$(GRAMMAR
$(GNAME ArrayLiteral):
    $(D [) $(GLINK ArgumentList)$(OPT) $(D ])
)

    $(P Array literals are a comma-separated list of $(GLINK AssignExpression)s
        between square brackets $(D [) and $(D ]).
        The $(I AssignExpression)s form the elements of a dynamic array,
        the length of the array is the number of elements.
        The common type of the all elements is taken to be the type of
        the array element, and all elements are implicitly converted
        to that type.)

        ---
        auto a1 = [1,2,3];  // type is int[], with elements 1, 2 and 3
        auto a2 = [1u,2,3]; // type is uint[], with elements 1u, 2u, and 3u
        ---

    $(P By default, an array literal is typed as a dynamic array, but the element
        count is known at compile time. So all array literals can be
        implicitly converted to static array types.)

        -------------
        void foo(long[2] a)
        {
            assert(a == [2, 3]);
        }
        void bar(ref long[2] a)
        {
            assert(a == [2, 3]);
            a[0] = 4;
            a[1] = 5;
            assert(a == [4, 5]);
        }
        void baz(const char[3] a) {}

        void main()
        {
            long[] arr = [1, 2, 3];

            foo(arr[1 .. 3]);
            assert(arr == [1, 2, 3]);

            bar(arr[1 .. 3]);
            assert(arr == [1, 4, 5]);

          //baz(arr[1 .. 3]); // cannot match length
        }
        -------------

    $(P If any of the arguments in the $(GLINK ArgumentList) are
        a $(I ValueSeq), then the elements of the $(I ValueSeq)
        are inserted as arguments in place of the sequence.
    )

    $(P Array literals are allocated on the memory managed heap.
        Thus, they can be returned safely from functions:)

        ---
        int[] foo()
        {
            return [1, 2, 3];
        }
        ---

    $(P When array literals are cast to another array type, each
        element of the array is cast to the new element type.
        When arrays that are not literals are cast, the array is
        reinterpreted as the new type, and the length is recomputed:)

        ---
        import std.stdio;

        void main()
        {
            // cast array literal
            const short[] ct = cast(short[]) [cast(byte)1, 1];
            // this is equivalent with:
            // const short[] ct = [cast(short)1, cast(short)1];
            writeln(ct);  // writes [1, 1]

            // cast other array expression
            // --> normal behavior of CastExpression
            byte[] arr = [cast(byte)1, cast(byte)1];
            short[] rt = cast(short[]) arr;
            writeln(rt);  // writes [257]
        }
        ---

        In other words, casting literal expression will change the literal type.

$(H3 $(LNAME2 associative_array_literals, Associative Array Literals))

$(GRAMMAR
$(GNAME AssocArrayLiteral):
    $(D [) $(GLINK KeyValuePairs) $(D ])

$(GNAME KeyValuePairs):
    $(GLINK KeyValuePair)
    $(GLINK KeyValuePair) $(D ,) $(I KeyValuePairs)

$(GNAME KeyValuePair):
    $(GLINK KeyExpression) $(D :) $(GLINK ValueExpression)

$(GNAME KeyExpression):
    $(GLINK AssignExpression)

$(GNAME ValueExpression):
    $(GLINK AssignExpression)
)

    $(P Associative array literals are a comma-separated list of
        $(I key)$(D :)$(I value) pairs
        between square brackets $(D [) and $(D ]).
        The list cannot be empty.
        The common type of the all keys is taken to be the key type of
        the associative array, and all keys are implicitly converted
        to that type.
        The common type of the all values is taken to be the value type of
        the associative array, and all values are implicitly converted
        to that type.
        An $(I AssocArrayLiteral) cannot be used to statically initialize
        anything.)

        ---
        [21u:"he", 38:"ho", 2:"hi"];  // type is string[uint],
                                      // with keys 21u, 38u and 2u
                                      // and values "he", "ho", and "hi"
        ---

    $(P If any of the keys or values in the $(I KeyValuePairs) are
        a $(I ValueSeq), then the elements of the $(I ValueSeq)
        are inserted as arguments in place of the sequence.
    )

$(H3 $(LNAME2 function_literals, Function Literals))

$(GRAMMAR
$(GNAME FunctionLiteral):
    $(D function) $(GLINK2 declaration, Type)$(OPT) $(GLINK ParameterAttributes) $(OPT) $(GLINK FunctionLiteralBody)
    $(D delegate) $(GLINK2 declaration, Type)$(OPT) $(GLINK ParameterMemberAttributes) $(OPT) $(GLINK FunctionLiteralBody)
    $(GLINK ParameterMemberAttributes) $(GLINK FunctionLiteralBody)
    $(GLINK FunctionLiteralBody)
    $(GLINK Lambda)

$(GNAME ParameterAttributes):
    $(GLINK2 function, Parameters) $(GLINK2 function, FunctionAttributes)$(OPT)

$(GNAME ParameterMemberAttributes):
    $(GLINK2 function, Parameters) $(GLINK2 function, MemberFunctionAttributes)$(OPT)

$(GNAME FunctionLiteralBody):
    $(GLINK2 statement, BlockStatement)
    $(GLINK2 function, FunctionContracts)$(OPT) $(GLINK2 function, BodyStatement)
)

    $(P $(I FunctionLiteral)s enable embedding anonymous functions
        and anonymous delegates directly into expressions.
        $(I Type) is the return type of the function or delegate,
        if omitted it is inferred from any $(I ReturnStatement)s
        in the $(I FunctionLiteralBody).
        $(D $(LPAREN)) $(GLINK ArgumentList) $(D $(RPAREN))
        forms the arguments to the function.
        If omitted it defaults to the empty argument list $(D ( )).
        The type of a function literal is pointer to function or
        pointer to delegate.
        If the keywords $(D function) or $(D delegate) are omitted,
        it is inferred from whether $(I FunctionLiteralBody) is actually
        accessing to the outer context.
    )

    $(P For example:)

        -------------
        int function(char c) fp; // declare pointer to a function

        void test()
        {
            static int foo(char c) { return 6; }

            fp = &foo;
        }
        -------------

        is exactly equivalent to:

        -------------
        int function(char c) fp;

        void test()
        {
            fp = function int(char c) { return 6;} ;
        }
        -------------

    $(P Also:)

        -------------
        int abc(int delegate(int i));

        void test()
        {
            int b = 3;
            int foo(int c) { return 6 + b; }

            abc(&foo);
        }
        -------------

        is exactly equivalent to:

        -------------
        int abc(int delegate(int i));

        void test()
        {
            int b = 3;

            abc( delegate int(int c) { return 6 + b; } );
        }
        -------------

    $(P and the following where the return type $(D int) and
        $(D function)/$(D delegate) are inferred:)

        -------------
        int abc(int delegate(int i));
        int def(int function(int s));

        void test()
        {
            int b = 3;

            abc( (int c) { return 6 + b; } );  // inferred to delegate
            def( (int c) { return c * 2; } );  // inferred to function
          //def( (int c) { return c * b; } );  // error!
            // Because the FunctionLiteralBody accesses b, then the function literal type
            // is inferred to delegate. But def cannot receive delegate.
        }
        -------------

    $(P If the type of a function literal can be uniquely determined from its context,
        the parameter type inference is possible.)

        -------------
        void foo(int function(int) fp);

        void test()
        {
            int function(int) fp = (n) { return n * 2; };
            // The type of parameter n is inferred to int.

            foo((n) { return n * 2; });
            // The type of parameter n is inferred to int.
        }
        -------------

    $(P Anonymous delegates can behave like arbitrary statement literals.
        For example, here an arbitrary statement is executed by a loop:)

        -------------
        double test()
        {
            double d = 7.6;
            float f = 2.3;

            void loop(int k, int j, void delegate() statement)
            {
                for (int i = k; i < j; i++)
                {
                    statement();
                }
            }

            loop(5, 100, { d += 1; });
            loop(3, 10,  { f += 3; });

            return d + f;
        }
        -------------

    $(P When comparing with $(DDSUBLINK spec/function, nested, nested functions),
        the $(D function) form is analogous to static
        or non-nested functions, and the $(D delegate) form is
        analogous to non-static nested functions. In other words,
        a delegate literal can access stack variables in its enclosing
        function, a function literal cannot.
    )

$(H3 $(LNAME2 lambdas, Lambdas))

$(GRAMMAR
$(GNAME Lambda):
    $(D function) $(GLINK2 declaration, Type)$(OPT) $(GLINK ParameterAttributes) $(D =>) $(GLINK AssignExpression)
    $(D delegate) $(GLINK2 declaration, Type)$(OPT) $(GLINK ParameterMemberAttributes) $(D =>) $(GLINK AssignExpression)
    $(GLINK ParameterMemberAttributes) $(D =>) $(GLINK AssignExpression)
    $(IDENTIFIER) $(D =>) $(GLINK AssignExpression)
)

    $(P $(I Lambda)s are a shorthand syntax for $(GLINK FunctionLiteral)s.)

    $(OL
        $(LI $(P Just one $(IDENTIFIER) is rewritten to
             $(GLINK2 function, Parameters):)

             $(D $(LPAREN)) $(IDENTIFIER) $(D $(RPAREN))
        )
        $(LI $(P The following part $(D =>) $(I AssignExpression) is rewritten to
             $(GLINK FunctionLiteralBody):)

             $(D { return) $(I AssignExpression) $(D ; })
        )
    )

    $(P Example usage:)

        ---
        import std.stdio;

        void main()
        {
            auto i = 3;
            auto twice  = function (int x) => x * 2;
            auto square = delegate (int x) => x * x;

            auto n = 5;
            auto mul_n = (int x) => x * n;

            writeln(twice(i));   // prints 6
            writeln(square(i));  // prints 9
            writeln(mul_n(i));   // prints 15
        }
        ---

$(H3 $(LNAME2 uniform_construction_syntax, Uniform construction syntax for built-in scalar types))

    $(P The implicit conversions of built-in scalar types can be explicitly
        represented by using function call syntax. For example:)

        ---
        auto a = short(1);  // implicitly convert an integer literal '1' to short
        auto b = double(a); // implicitly convert a short variable 'a' to double
        auto c = byte(128); // error, 128 cannot be represented in a byte
        ---

    $(P If the argument is omitted, it means default construction of the
        scalar type:)

        ---
        auto a = ushort();  // same as: ushort.init
        auto b = wchar();   // same as: wchar.init
        auto c = creal();   // same as: creal.init
        ---


$(H3 $(LNAME2 assert_expressions, Assert Expressions))

$(GRAMMAR
$(GNAME AssertExpression):
    $(D assert $(LPAREN)) $(GLINK AssignExpression) $(D ,)$(OPT) $(D $(RPAREN))
    $(D assert $(LPAREN)) $(GLINK AssignExpression) $(D ,) $(GLINK AssignExpression) $(D ,)$(OPT) $(D $(RPAREN))
)

    $(P The first $(I AssignExpression) must evaluate to true. If it does not, an $(I Assert Failure)
    has occurred and the program enters an $(I Invalid State).
    )

    $(P If the first $(I AssignExpression) consists entirely of compile time constants,
    and evaluates to false, it is a special case; it
    signifies that it is unreachable code.
    Compile Time Function Execution (CTFE) is not attempted.
    )

    $(P $(I AssertExpression) has different semantics if it is in a
    $(DDLINK spec/unittest, Unit Tests, $(D unittest)) or
    $(DDLINK spec/contracts, Contract Programming, $(D in) contract).
    )

    $(P The second $(I AssignExpression), if present, must be implicitly
        convertible to type $(D const(char)[]).
    )

    $(P If the first $(I AssignExpression) is a reference to a class instance for
    which a $(DDSUBLINK spec/class, invariants, Class Invariant) exists, the $(I Class Invariant) must hold.
    )

    $(P If the first $(I AssignExpression) is a pointer to a struct instance for
    which a $(I Struct Invariant) exists, the $(I Struct Invariant) must hold.
    )

    $(P The type of an $(I AssertExpression) is $(D void).
    )

    $(UNDEFINED_BEHAVIOR Once in an $(I Invalid State) the behavior of the continuing execution
    of the program is undefined.)

    $(IMPLEMENTATION_DEFINED Whether the first $(I AssertExpression) is evaluated
    or not at runtime is typically set with a compiler switch. If it is not evaluated,
    any side effects specified by the $(I AssertExpression) may not occur.
    The behavior if the first $(I AssertExpression) is evaluated and is false
    is also typically set with a compiler switch and may include these options:
    $(OL
        $(LI continuing execution)
        $(LI immediately halting via execution of a special CPU instruction)
        $(LI aborting the program)
        $(LI calling the assert failure function in the corresponding C
        runtime library)
        $(LI throwing the $(D AssertError) exception in the D runtime library)
    )
    If the optional second $(I AssignExpression) is provided, the implementation may
    evaluate it and print the resulting message upon assert failure:

        ----
        void main()
        {
            assert(0, "an" ~ " error message");
        }
        ----

    $(P When compiled and run, it will produce the message:)

    $(CONSOLE core.exception.AssertError@test.d(3) an error message)

    $(P The implementation may handle the case of the first $(I AssignExpression) evaluating at compile
    time to false differently in that in release mode
    it may simply generate a $(D HLT) instruction or equivalent.
    )
    )

    $(BEST_PRACTICE
    $(OL
        $(LI Do not have side effects in either $(I AssignExpression) that subsequent code
        depends on.)
        $(LI $(I AssertExpressions) are intended to detect bugs in the program, do
        not use for detecting input or environmental errors.)
        $(LI Do not attempt to resume normal execution after an $(I Assert Failure).)
    )
    )

$(H3 $(LNAME2 mixin_expressions, Mixin Expressions))

$(GRAMMAR
$(GNAME MixinExpression):
    $(D mixin $(LPAREN)) $(GLINK AssignExpression) $(D $(RPAREN))
)

    $(P The $(I AssignExpression) must evaluate at compile time
        to a constant string.
        The text contents of the string must be compilable as a valid
        $(I Expression), and is compiled as such.)

        ---
        int foo(int x)
        {
            return mixin("x + 1") * 7;  // same as ((x + 1) * 7)
        }
        ---

$(H3 $(LNAME2 import_expressions, Import Expressions))

$(GRAMMAR
$(GNAME ImportExpression):
    $(D import $(LPAREN)) $(GLINK AssignExpression) $(D $(RPAREN))
)

    $(P The $(I AssignExpression) must evaluate at compile time
        to a constant string.
        The text contents of the string are interpreted as a file
        name. The file is read, and the exact contents of the file
        become a string literal.
    )

    $(P Implementations may restrict the file name in order to avoid
        directory traversal security vulnerabilities.
        A possible restriction might be to disallow any path components
        in the file name.
    )

    $(P Note that by default an import expression will not compile unless
        you pass one or more paths via the $(B -J) switch. This tells the compiler
        where it should look for the files to import. This is a security feature.)

        ---
        void foo()
        {
            // Prints contents of file foo.txt
            writeln(import("foo.txt"));
        }
        ---

$(H3 $(LNAME2 typeid_expressions, Typeid Expressions))

$(GRAMMAR
$(GNAME TypeidExpression):
    $(D typeid $(LPAREN)) $(GLINK2 declaration, Type) $(D $(RPAREN))
    $(D typeid $(LPAREN)) $(GLINK Expression) $(D $(RPAREN))
)

    $(P If $(I Type), returns an instance of class
        $(DPLLINK $(ROOT_DIR)phobos/object.html, $(D TypeInfo))
        corresponding
        to $(I Type).
    )

    $(P If $(I Expression), returns an instance of class
        $(DPLLINK $(ROOT_DIR)phobos/object.html, $(D TypeInfo))
        corresponding
        to the type of the $(I Expression).
        If the type is a class, it returns the $(D TypeInfo)
        of the dynamic type (i.e. the most derived type).
        The $(I Expression) is always executed.)

        ---
        class A { }
        class B : A { }

        void main()
        {
            writeln(typeid(int));        // int
            uint i;
            writeln(typeid(i++));        // uint
            writeln(i);                  // 1
            A a = new B();
            writeln(typeid(a));          // B
            writeln(typeid(typeof(a)));  // A
        }
        ---

$(H3 $(LNAME2 is_expression, IsExpression))

$(GRAMMAR
$(GNAME IsExpression):
    $(D is $(LPAREN)) $(GLINK2 declaration, Type) $(D $(RPAREN))
    $(D is $(LPAREN)) $(GLINK2 declaration, Type) $(D :) $(GLINK TypeSpecialization) $(D $(RPAREN))
    $(D is $(LPAREN)) $(GLINK2 declaration, Type) $(D ==) $(GLINK TypeSpecialization) $(D $(RPAREN))
    $(D is $(LPAREN)) $(GLINK2 declaration, Type) $(D :) $(GLINK TypeSpecialization) $(D ,) $(GLINK2 template, TemplateParameterList) $(D $(RPAREN))
    $(D is $(LPAREN)) $(GLINK2 declaration, Type) $(D ==) $(GLINK TypeSpecialization) $(D ,) $(GLINK2 template, TemplateParameterList) $(D $(RPAREN))
    $(D is $(LPAREN)) $(GLINK2 declaration, Type) $(IDENTIFIER) $(D $(RPAREN))
    $(D is $(LPAREN)) $(GLINK2 declaration, Type) $(IDENTIFIER) $(D :) $(GLINK TypeSpecialization) $(D $(RPAREN))
    $(D is $(LPAREN)) $(GLINK2 declaration, Type) $(IDENTIFIER) $(D ==) $(GLINK TypeSpecialization) $(D $(RPAREN))
    $(D is $(LPAREN)) $(GLINK2 declaration, Type) $(IDENTIFIER) $(D :) $(GLINK TypeSpecialization) $(D ,) $(GLINK2 template, TemplateParameterList) $(D $(RPAREN))
    $(D is $(LPAREN)) $(GLINK2 declaration, Type) $(IDENTIFIER) $(D ==) $(GLINK TypeSpecialization) $(D ,) $(GLINK2 template, TemplateParameterList) $(D $(RPAREN))


$(GNAME TypeSpecialization):
    $(GLINK2 declaration, Type)
    $(D struct)
    $(D union)
    $(D class)
    $(D interface)
    $(D enum)
    $(D function)
    $(D delegate)
    $(D super)
    $(D const)
    $(D immutable)
    $(D inout)
    $(D shared)
    $(D return)
    $(D __parameters)
)

    $(P $(I IsExpression)s are evaluated at compile time and are
        used for checking for valid types, comparing types for equivalence,
        determining if one type can be implicitly converted to another,
        and deducing the subtypes of a type.
        The result of an $(I IsExpression) is a boolean of value `true`
        if the condition is satisfied. If the condition is not satisfied,
        the result is a boolean of value `false`.
    )

    $(P $(I Type) is the type being tested. It must be syntactically
        correct, but it need not be semantically correct.
        If it is not semantically correct, the condition is not satisfied.
    )

    $(P $(IDENTIFIER) is declared to be an alias of the resulting
        type if the condition is satisfied. The $(IDENTIFIER) forms
        can only be used if the $(I IsExpression) appears in a
        $(GLINK2 version, StaticIfCondition).
    )

    $(P $(I TypeSpecialization) is the type that $(I Type) is being
        compared against.
    )

    $(P The forms of the $(I IsExpression) are:
    )

    $(OL

        $(LI $(D is $(LPAREN)) $(I Type) $(D $(RPAREN))$(BR)
        The condition is satisfied if $(D Type) is semantically
        correct (it must be syntactically correct regardless).

-------------
alias int func(int);    // func is a alias to a function type
void foo()
{
    if (is(func[]))     // not satisfied because arrays of
                        // functions are not allowed
        writeln("satisfied");
    else
        writeln("not satisfied");

    if (is([][]))       // error, [][] is not a syntactically valid type
        ...
}
-------------
        )

        $(LI $(D is $(LPAREN)) $(I Type) $(D :) $(I TypeSpecialization) $(D $(RPAREN))$(BR)
        The condition is satisfied if $(I Type) is semantically
        correct and it is the same as
        or can be implicitly converted to $(I TypeSpecialization).
        $(I TypeSpecialization) is only allowed to be a $(I Type).

-------------
alias Bar = short;
void foo()
{
    if (is(Bar : int))   // satisfied because short can be
                         // implicitly converted to int
        writeln("satisfied");
    else
        writeln("not satisfied");
}
-------------
        )

        $(LI $(D is $(LPAREN)) $(I Type) $(D ==) $(I TypeSpecialization) $(D $(RPAREN))$(BR)

        The condition is satisfied if $(I Type) is semantically correct and is
        the same type as $(I TypeSpecialization).

        If $(I TypeSpecialization) is one of

                $(D struct)
                $(D union)
                $(D class)
                $(D interface)
                $(D enum)
                $(D function)
                $(D delegate)
           $(D const)
                $(D immutable)
                $(D shared)

        then the condition is satisfied if $(I Type) is one of those.

-------------
alias Bar = short;
void foo()
{
    if (is(Bar == int))   // not satisfied because short is not
                          // the same type as int
        writeln("satisfied");
    else
        writeln("not satisfied");
}
-------------
        )

        $(LI $(D is $(LPAREN)) $(I Type) $(I Identifier) $(D $(RPAREN))$(BR)
        The condition is satisfied if $(I Type) is semantically
        correct. If so, $(I Identifier)
        is declared to be an alias of $(I Type).

-------------
alias Bar = short;
void foo()
{
    static if (is(Bar T))
        alias S = T;
    else
        alias S = long;

    writeln(typeid(S)); // prints "short"
    if (is(Bar T))      // error, Identifier T form can
                        // only be in StaticIfConditions
        ...
}
-------------
        )

        $(LI $(D is $(LPAREN)) $(I Type) $(I Identifier) $(D :) $(I TypeSpecialization) $(D $(RPAREN))$(BR)

        The condition is satisfied if $(I Type) is the same as
        $(I TypeSpecialization), or if $(I Type) is a class and
        $(I TypeSpecialization) is a base class or base interface
        of it.
        The $(I Identifier) is declared to be either an alias of the
        $(I TypeSpecialization) or, if $(I TypeSpecialization) is
        dependent on $(I Identifier), the deduced type.

-------------
alias Bar = int;
alias Abc = long*;
void foo()
{
    static if (is(Bar T : int))
        alias S = T;
    else
        alias S = long;

    writeln(typeid(S));  // prints "int"

    static if (is(Abc U : U*))
    {
        U u;
        writeln(typeid(typeof(u)));  // prints "long"
    }
}
-------------

        The way the type of $(I Identifier) is determined is analogous
        to the way template parameter types are determined by
        $(GLINK2 template, TemplateTypeParameterSpecialization).
        )

        $(LI $(D is $(LPAREN)) $(I Type) $(I Identifier) $(D ==) $(I TypeSpecialization) $(D $(RPAREN))$(BR)


        The condition is satisfied if $(I Type) is semantically
        correct and is the same as $(I TypeSpecialization).
        The $(I Identifier) is declared to be either an alias of the
        $(I TypeSpecialization) or, if $(I TypeSpecialization) is
        dependent on $(I Identifier), the deduced type.

        If $(I TypeSpecialization) is one of
               $(D struct)
                $(D union)
                $(D class)
                $(D interface)
                $(D enum)
                $(D function)
                $(D delegate)
           $(D const)
                $(D immutable)
                $(D shared)

        then the condition is satisfied if $(I Type) is one of those.
        Furthermore, $(I Identifier) is set to be an alias of the type:

        $(TABLE_2COLS ,
        $(THEAD keyword, alias type for $(I Identifier))

        $(TROW $(CODE struct), $(I Type))
        $(TROW $(D union), $(I Type))
        $(TROW $(D class), $(I Type))
        $(TROW $(D interface), $(I Type))
        $(TROW $(D super), $(I TypeSeq) of base classes and interfaces)
        $(TROW $(D enum), the base type of the enum)
        $(TROW $(D function), $(ARGS $(I TypeSeq) of the function parameter types.
             For C- and D-style variadic functions,
             only the non-variadic parameters are included.
             For typesafe variadic functions, the $(D ...) is ignored.))
        $(TROW $(CODE delegate), the function type of the delegate)
        $(TROW $(CODE return), $(ARGS the return type of the function, delegate, or function pointer))
        $(TROW $(CODE __parameters), $(ARGS the parameter sequence of a function, delegate, or function pointer.
         This includes the parameter types, names, and default values.))
        $(TROW $(D const), $(I Type))
        $(TROW
        $(D immutable),
        $(I Type)
        )
        $(TROW
        $(CODE shared),
        $(I Type)
        )

        )

-------------
alias Bar = short;
enum E : byte { Emember }
void foo()
{
    static if (is(Bar T == int))   // not satisfied, short is not int
        alias S = T;
    alias U = T;                   // error, T is not defined

    static if (is(E V == enum))    // satisified, E is an enum
        V v;                       // v is declared to be a byte
}
-------------

        )

        $(LI $(D is $(LPAREN)) $(I Type) $(D :) $(I TypeSpecialization) $(D ,) $(GLINK2 template, TemplateParameterList) $(D $(RPAREN))$(BR)
             $(D is $(LPAREN)) $(I Type) $(D ==) $(I TypeSpecialization) $(D ,) $(GLINK2 template, TemplateParameterList) $(D $(RPAREN))$(BR)
             $(D is $(LPAREN)) $(I Type) $(I Identifier) $(D :) $(I TypeSpecialization) $(D ,) $(GLINK2 template, TemplateParameterList) $(D $(RPAREN))$(BR)
             $(D is $(LPAREN)) $(I Type) $(I Identifier) $(D ==) $(I TypeSpecialization) $(D ,) $(GLINK2 template, TemplateParameterList) $(D $(RPAREN))

        More complex types can be pattern matched; the
        $(GLINK2 template, TemplateParameterList) declares symbols based on the
        parts of the pattern that are matched, analogously to the
        way implied template parameters are matched.

---
import std.stdio, std.typecons;

void main()
{
    alias Tup = Tuple!(int, string);
    alias AA = long[char[]];

    static if (is(Tup : Template!Args, alias Template, Args...))
    {
        writeln(__traits(isSame, Template, Tuple)); // true
        writeln(is(Template!(int, long) == Tup));  // true
        writeln(typeid(Args[0]));  // int
        writeln(typeid(Args[1]));  // immutable(char)[]
    }

    static if (is(AA T : T[U], U : const char[]))
    {
        writeln(typeid(T));  // long
        writeln(typeid(U));  // const char[]
    }

    static if (is(AA A : A[B], B : int))
    {
        assert(0);  // should not match, as B is not an int
    }

    static if (is(int[10] W : W[len], int len))
    {
        writeln(typeid(W));  // int
        writeln(len);        // 10
    }

    static if (is(int[10] X : X[len], int len : 5))
    {
        assert(0);  // should not match, len should be 10
    }
}
---

        )

    )

$(H2 $(LNAME2 associativity, Associativity and Commutativity))

    $(P An implementation may rearrange the evaluation of expressions
        according to arithmetic associativity and commutativity rules
        as long as, within that thread of execution, no observable
        difference is possible.
    )

    $(P This rule precludes any associative or commutative reordering of
        floating point expressions.
    )
$(SPEC_SUBNAV_PREV_NEXT pragma, Pragmas, statement, Statements)
)

Macros:
        CHAPTER=10
        TITLE=Expressions
        IDENTIFIER=$(GLINK2 lex, Identifier)
        _=
