Ddoc

$(SPEC_S Classes,

$(HEADERNAV_TOC)

        $(P The object-oriented features of D all come from classes. The class
        hierarchy
        has as its root the class Object. Object defines a minimum level of functionality
        that each derived class has, and a default implementation for that functionality.
        )

        $(P Classes are programmer defined types. Support for classes are what
        make D an object oriented language, giving it encapsulation, inheritance,
        and polymorphism. D classes support the single inheritance paradigm, extended
        by adding support for interfaces. Class objects are instantiated by reference
        only.
        )

        $(P A class can be exported, which means its name and all its
        non-private
        members are exposed externally to the DLL or EXE.
        )

        $(P A class declaration is defined:
        )

$(GRAMMAR
$(GNAME ClassDeclaration):
    $(D class) $(GLINK_LEX Identifier) $(D ;)
    $(D class) $(GLINK_LEX Identifier) $(GLINK BaseClassList)$(OPT) $(GLINK2 struct, AggregateBody)
    $(GLINK2 template, ClassTemplateDeclaration)

$(GNAME BaseClassList):
    $(D :) $(GLINK SuperClassOrInterface)
    $(D :) $(GLINK SuperClassOrInterface) $(D ,) $(GLINK Interfaces)

$(GNAME SuperClassOrInterface):
    $(GLINK2 type, BasicType)

$(GNAME Interfaces):
    $(GLINK Interface)
    $(GLINK Interface) $(D ,) $(GSELF Interfaces)

$(GNAME Interface):
    $(GLINK2 type, BasicType)
)

$(P A class consists of:)

$(COMMENT list of notable components, not exhaustive)
$(UL
        $(LI a $(RELATIVE_LINK2 super_class, super class))
        $(LI $(DDLINK spec/interface, Interfaces, interfaces)
        $(LI dynamic fields)
        $(LI $(DDSUBLINK spec/attribute, static, static) fields)
        $(LI $(RELATIVE_LINK2 nested, nested classes))
        $(LI $(RELATIVE_LINK2 member-functions, member functions))
        $(UL
            $(LI static member functions)
            $(LI $(DDSUBLINK spec/function, virtual-functions, Virtual Functions))
            $(LI $(RELATIVE_LINK2 constructors, Constructors))
            $(LI $(RELATIVE_LINK2 destructors, Destructors))
            $(LI $(RELATIVE_LINK2 invariants, Class Invariants))
            $(LI $(DDLINK spec/operatoroverloading, Operator Overloading, Operator Overloading))
        )
        $(LI other declarations (see $(GLINK2 module, DeclDef)))
        )
)

$(P A class is defined:)

------
class Foo
{
    ... members ...
}
------

$(PANEL
        $(NOTE Unlike C++, there is no trailing $(D ;) after the closing $(D }) of the class
        definition.
        It is also not possible to declare a variable `var` inline:)

------
class Foo { } var;
------

        Instead, use:

------
class Foo { }
Foo var;
------
)

$(H2 $(LNAME2 access_control, Access Control))

        $(P Access to class members is controlled using
        $(DDSUBLINK spec/attribute, visibility_attributes,
        visibility attributes).
        The default visibility attribute is $(D public).
        )

$(H2 $(LNAME2 super_class, Super Class))

        $(P
        All classes inherit from a super class. If one is not specified,
        a class inherits from $(REF1 Object, object). `Object` forms the root
        of the D class inheritance hierarchy.
        )

---
class A { }     // A inherits from Object
class B : A { } // B inherits from A
---

        $(P Multiple class inheritance is not supported, however a class can inherit from
        multiple $(DDLINK spec/interface, Interfaces, interfaces).
        If a super class is declared, it must come before any interfaces.
        Commas are used to separate inherited types.)


$(H2 $(LNAME2 fields, Fields))

        $(P Class members are always accessed with the `.` operator.
        )

        $(P Members of a base class can be accessed by prepending the name of
        the base class followed by a dot:)

---
class A { int a; int a2;}
class B : A { int a; }

void foo(B b)
{
    b.a = 3;   // accesses field B.a
    b.a2 = 4;  // accesses field A.a2
    b.A.a = 5; // accesses field A.a
}
---

        $(P The D compiler is free to rearrange the order of fields in a class to
        optimally pack them in an implementation-defined manner.
        Consider the fields much like the local
        variables in a function -
        the compiler assigns some to registers and shuffles others around all to
        get the optimal
        stack frame layout. This frees the code designer to organize the fields
        in a manner that
        makes the code more readable rather than being forced to organize it
        according to
        machine optimization rules. Explicit control of field layout is provided
        by struct/union
        types, not classes.
        )

        $(P Fields of `extern(Objective-C)` classes have a dynamic offset. That
        means that the base class can change (add or remove instance variables)
        without the subclasses needing to recompile or relink.
        )

$(H3 $(LNAME2 field_properties, Field Properties))

        $(P The $(D .offsetof) property gives the offset in bytes of the field
        from the beginning of the class instantiation.
        `.offsetof` is not available for fields of `extern(Objective-C)` classes
        due to their fields having a dynamic offset.
        )

$(H2 $(LNAME2 class_properties, Class Properties))

        $(P The $(D .tupleof) property is an
        $(DDSUBLINK spec/template, homogeneous_sequences, lvalue sequence)
        of all the non-static fields in the class, excluding the hidden fields and
        the fields in the base class.)
        $(P The order of the fields in the tuple matches the order in which the fields are declared.)
        $(NOTE `.tupleof` is not available for `extern(Objective-C)` classes due to
        their fields having a dynamic offset.
        )
$(SPEC_RUNNABLE_EXAMPLE_RUN
---
class Foo { int x; long y; }

static assert(__traits(identifier, Foo.tupleof[0]) == "x");
static assert(is(typeof(Foo.tupleof)[1] == long));

void main()
{
    import std.stdio;

    auto foo = new Foo;
    foo.tupleof[0] = 1; // set foo.x to 1
    foo.tupleof[1] = 2; // set foo.y to 2
    foreach (ref x; foo.tupleof)
        x++;
    assert(foo.x == 2);
    assert(foo.y == 3);

    auto bar = new Foo;
    bar.tupleof = foo.tupleof; // copy fields
    assert(bar.x == 2);
    assert(bar.y == 3);
}
---
)

$(H3 $(LNAME2 hidden-fields, Accessing Hidden Fields))

        $(P The $(RELATIVE_LINK2 outer-property, `.outer` property) for
        a nested class instance provides either the parent class instance,
        or the parent function's context pointer when there is no parent
        class.)

        $(P The properties $(D .__vptr) and $(D .__monitor) give access
        to the class object's vtbl[] and monitor, respectively, but
        should not be used in user code.
        )

$(H2 $(LNAME2 member-functions, Member Functions (a.k.a. Methods)))

        $(P Non-static member functions have an extra hidden parameter
        called $(DDSUBLINK spec/expression, this, `this`) through which the class object's other members
        can be accessed.
        )

        $(P Non-static member functions can have, in addition to the usual
        $(GLINK2 function, FunctionAttribute)s, the attributes
        $(D const), $(D immutable), $(D shared), $(D inout), $(D scope) or $(D return scope).
        These attributes apply to the hidden $(I this) parameter.
        )
$(SPEC_RUNNABLE_EXAMPLE_FAIL
---
class C
{
    int a;
    void foo() const
    {
        a = 3; // error, 'this' is const
    }
    void foo() immutable
    {
        a = 3; // error, 'this' is immutable
    }
    C bar() @safe scope
    {
        return this; // error, 'this' is scope
    }
}
---
)

$(H3 $(LNAME2 objc-member-functions, Objective-C linkage))

        $(P Static member functions with
        `Objective-C` linkage also have an extra hidden parameter called $(I this)
        through which the class object's other members can be accessed.
        )

        $(P Member functions with Objective-C linkage have an additional
        hidden, anonymous, parameter which is the selector the function was
        called with.
        )

        $(P Static member functions with Objective-C linkage are placed in
        a hidden nested metaclass as non-static member functions.
        )


$(H2 $(LNAME2 synchronized-methods, Synchronized Method Calls))

        $(P Member functions of a (non-`synchronized`) class can be individually
        marked as `synchronized`.
        The class instance's monitor object will be locked when the method is
        called and unlocked when the call terminates.
        )

        $(P A synchronized method can only be called on a
        $(DDSUBLINK spec/const3, shared, `shared`) class instance.)

$(SPEC_RUNNABLE_EXAMPLE_COMPILE
---
class C
{
    void foo();
    synchronized int bar();
}

void test(C c)
{
    c.foo; // OK
    //c.bar; // Error, `c` is not `shared`

    shared C sc = new shared C;
    //sc.foo; // Error, `foo` not callable using a `shared` object
    sc.bar; // OK
}
---
)
        $(P See also $(GLINK2 statement, SynchronizedStatement).)

$(H3 $(LNAME2 synchronized-classes, Synchronized Classes))

        $(P Each member function of a `synchronized` class is implicitly `synchronized`.
        A static member function is synchronized on the $(I classinfo)
        object for the class, which means that one monitor is used
        for all static member functions for that synchronized class.
        For non-static functions of a synchronized class, the monitor
        used is part of the class object. For example:
        )

        ---
        synchronized class Foo
        {
            void bar() { ...statements... }
        }
        ---

        $(P is equivalent to (as far as the monitors go):
        )

        ---
        synchronized class Foo
        {
            void bar()
            {
                synchronized (this) { ...statements... }
            }
        }
        ---
        $(NOTE `bar` uses a $(GLINK2 statement, SynchronizedStatement).)

        $(P Member fields of a synchronized class cannot be public:
        )

        ---
        synchronized class Foo
        {
            int foo;  // Error: public field
        }

        synchronized class Bar
        {
            private int bar;  // ok
        }
        ---

        $(NOTE struct types cannot be marked `synchronized`.)


$(H2 $(LNAME2 constructors, Constructors))

$(GRAMMAR
$(GNAME Constructor):
    $(D this) $(GLINK2 function, Parameters) $(GLINK2 function, MemberFunctionAttributes)$(OPT) $(GLINK2 function, FunctionBody)
    $(GLINK2 template, ConstructorTemplate)
)

        $(P Fields are by default initialized to the
        $(LNAME2 class-default-initializer, default initializer)
        for their type (usually 0 for integer types and
        NAN for floating point types).
        If the field declaration has an optional $(GLINK2 declaration, Initializer)
        that will be used instead of the default.
        )
        ------
        class Abc
        {
            int a;      // default initializer for a is 0
            long b = 7; // default initializer for b is 7
            float f;    // default initializer for f is NAN
        }
        ------

        $(P The $(I Initializer) is evaluated at compile time.)

        $(P This initialization is done before any constructors are
        called.)

        $(P Constructors are defined with a function name of $(D this)
        and have no return value:)

        ------
        class Foo
        {
            $(CODE_HIGHLIGHT this)(int x)  // declare constructor for Foo
            {   ...
            }
            $(CODE_HIGHLIGHT this)()
            {   ...
            }
        }
        ------

$(H3 $(LNAME2 base-construction, Base Class Construction))

        $(P Base class construction is done by calling the base class
        constructor by the name $(D super):)

        ------
        class A { this(int y) { } }

        class B : A
        {
            int j;
            this()
            {
                ...
                $(CODE_HIGHLIGHT super)(3);  // call base constructor A.this(3)
                ...
            }
        }
        ------

$(H3 $(LNAME2 delegating-constructors, Delegating Constructors))

        $(P A constructor can call another constructor for the same class
        in order to share common initializations.
        This is called a $(I delegating constructor):
        )

        ------
        class C
        {
            int j;
            this()
            {
                ...
            }
            this(int i)
            {
                $(CODE_HIGHLIGHT this)(); // delegating constructor call
                j = i;
            }
        }
        ------

        $(P The following restrictions apply:)

    $(OL
        $(LI It is illegal for constructors to mutually call each other.

        ------
        this() { this(1); }
        this(int i) { this(); } // illegal, cyclic constructor calls
        ------

        $(IMPLEMENTATION_DEFINED The compiler is not required to detect
        cyclic constructor calls.)

        $(UNDEFINED_BEHAVIOR If the program executes with cyclic constructor
        calls.)
        )

        $(LI If a constructor's code contains a delegating constructor call, all
        possible execution paths through the constructor must make exactly one
        delegating constructor call:

        ------
        this() { a || super(); }       // illegal

        this() { (a) ? this(1) : super(); }     // ok

        this()
        {
            for (...)
            {
                super();  // illegal, inside loop
            }
        }
        ------
        )

        $(LI It is illegal to refer to $(D this) implicitly or explicitly
        prior to making a delegating constructor call.)

        $(LI Delegating constructor calls cannot appear after labels.)
    )

$(H3 $(LNAME2 implicit-base-construction, Implicit Base Class Construction))

        $(P If there is no constructor for a class, but there is a constructor
        for the base class, a default constructor is implicitly generated with
        the form:)

        ------
        this() { }
        ------

        $(P If no calls to a delegating constructor or $(D super) appear in a
        constructor, and the base class has a nullary constructor, a call to
        `super()` is inserted at the beginning of the constructor. If that
        base class has a constructor that requires arguments and no
        nullary constructor, a matching call to `super` is required.)

$(H3 $(LNAME2 class-instantiation, Class Instantiation))

        $(P Instances of class objects are created with a $(GLINK2 expression, NewExpression):)

        ------
        A a = new A(3);
        ------

        $(P A $(DDSUBLINK spec/attribute, scope-class-var, `scope` class instance)
        is allocated on the stack.)

        $(P The following steps happen:)

    $(OL
        $(LI Storage is allocated for the object.
        If this fails, rather than return $(D null), an
        $(LINK2 $(ROOT_DIR)library/core/exception/out_of_memory_error.html, OutOfMemoryError) is thrown.
        Thus, tedious checks for null references are unnecessary.
        )

        $(LI The raw data is statically initialized using the values provided
        in the class definition.
        The pointer to the vtbl[] (the array of pointers to virtual functions)
        is assigned.
        Constructors are
        passed fully formed objects for which virtual functions can be called.
        This operation is equivalent to doing a memory copy of a static
        version of the object onto the newly allocated one.
        )

        $(LI If there is a constructor defined for the class,
        the constructor matching the
        argument list is called.
        )

        $(LI If a delegating constructor is not called, a call to the base
        class's default constructor is issued.)

        $(LI The body of the constructor is executed.)

        $(LI If class invariant checking is turned on, the class invariant
        is called at the end of the constructor.
        )
    )

$(H3 $(LNAME2 constructor-attributes, Constructor Attributes))

        $(P Constructors can have one of these member function attributes:
        $(D const), $(D immutable), and $(D shared). Construction of qualified
        objects will then be restricted to the implemented qualified constructors.
        )
        ------
        class C
        {
            this();   // non-shared mutable constructor
        }

        // create mutable object
        C m = new C();

        // create const object using mutable constructor
        const C c2 = new const C();

        // a mutable constructor cannot create an immutable object
        // immutable C i = new immutable C();

        // a mutable constructor cannot create a shared object
        // shared C s = new shared C();
        ------

        $(P Constructors can be overloaded with different attributes.
        )
        ------
        class C
        {
            this();               // non-shared mutable constructor
            this() shared;        // shared mutable constructor
            this() immutable;     // immutable constructor
        }

        C m = new C();
        shared s = new shared C();
        immutable i = new immutable C();
        ------

$(H4 $(LNAME2 pure-constructors, Pure Constructors))

        $(P If the constructor can create a unique object (e.g. if it is `pure`),
        the object can be implicitly convertible to any qualifiers.
        )
        ------
        class C
        {
            this() pure;
            // Based on the definition, this creates a mutable object. But the
            // created object cannot contain any mutable global data.
            // Therefore the created object is unique.

            this(int[] arr) immutable pure;
            // Based on the definition, this creates an immutable object. But
            // the argument int[] never appears in the created object so it
            // isn't implicitly convertible to immutable. Also, it cannot store
            // any immutable global data.
            // Therefore the created object is unique.
        }

        immutable i = new immutable C();           // this() pure is called
        shared s = new shared C();                 // this() pure is called
        C m = new C([1,2,3]);       // this(int[]) immutable pure is called
        ------

$(H3 $(LNAME2 field-init, Field initialization inside a constructor))

        $(P In a constructor body, the first instance of field assignment is
        its initialization.
        )

        ------
        class C
        {
            int num;
            this()
            {
                num = 1;  // initialization
                num = 2;  // assignment
            }
        }
        ------

       $(P If the field type has an $(LINK2 operatoroverloading.html#assignment, `opAssign`)
       method, it will not be used for initialization.)

        ------
        struct A
        {
            this(int n) {}
            void $(CODE_HIGHLIGHT opAssign)(A rhs) {}
        }
        class C
        {
            A val;
            this()
            {
                val = A(1);  // val is initialized to the value of A(1)
                val = A(2);  // rewritten to val.opAssign(A(2))
            }
        }
        ------

        $(P If the field type is not mutable, multiple initialization will be rejected.)

        ------
        class C
        {
            immutable int num;
            this()
            {
                num = 1;  // OK
                num = 2;  // Error: multiple field initialization
            }
        }
        ------

        $(P If the field is initialized on one path, it must be initialized on all paths.)
        ---
        class C
        {
            immutable int num;
            immutable int ber;
            this(int i)
            {
                if (i)
                    num = 3;   // initialization
                else
                    num = 4;   // initialization
            }
            this(long j)
            {
                j ? (num = 3) : (num = 4); // ok
                j || (ber = 3);  // error, intialized on only one path
                j && (ber = 3);  // error, intialized on only one path
            }
        }
        ---

        $(P A field initialization may not appear in a loop or after
        a label.)

        ------
        class C
        {
            immutable int num;
            immutable string str;
            this()
            {
                foreach (i; 0..2)
                {
                    num = 1;    // Error: field initialization not allowed in loops
                }
                size_t i = 0;
            Label:
                str = "hello";  // Error: field initialization not allowed after labels
                if (i++ < 2)
                    goto Label;
            }
        }
        ------

        $(P If a field's type has disabled default construction, then it must be initialized
        in the constructor.)
        ---
        struct S { int y; @disable this(); }

        class C
        {
            S s;
            this(S t) { s = t; }    // ok
            this(int i) { this(); } // ok
            this() { }              // error, s not initialized
        }
        ---

$(H2 $(LNAME2 destructors, Destructors))

$(GRAMMAR
$(GNAME Destructor):
    $(D ~ this ( )) $(GLINK2 function, MemberFunctionAttributes)$(OPT) $(GLINK2 function, FunctionBody)
)

        $(P The destructor function is called when:)

        * A live object is deleted by the garbage collector
        * A live $(DDSUBLINK spec/attribute, scope-class-var, `scope` class instance) goes out of scope
        * $(REF1 destroy, object) is called on the object

        $(P Example:)

        $(SPEC_RUNNABLE_EXAMPLE_RUN
        ------
        import std.stdio;

        class Foo
        {
            ~this() // destructor for Foo
            {
                writeln("dtor");
            }
        }

        void main()
        {
            auto foo = new Foo;
            destroy(foo);
            writeln("end");
        }
        ------
        )

        * Only one destructor can be declared per class, although
          other destructors $(DDSUBLINK spec/template-mixin, destructors, can be mixed in).
        * A destructor does not have any parameters or attributes.
        * A destructor is always virtual.

        $(P The destructor is expected to release any non-GC resources held by the
        object.
        )

        $(P The program can explicitly call the destructor of a live
        object immediately with $(REF1 destroy, object).
        The runtime marks the object so the destructor is never called twice.
        )

        $(P The destructor for the $(RELATIVE_LINK2 super_class, super class) automatically gets called when
        the destructor ends. There is no way to call the super class destructor
        explicitly.
        )

        $(IMPLEMENTATION_DEFINED The garbage collector is not guaranteed to run the destructor
        for all unreferenced objects.)

        $(PANEL
        $(DIVC spec-boxes, $(B Important:) The order in which the
        garbage collector calls destructors for unreferenced objects
        is not specified.
        This means that
        when the garbage collector calls a destructor for an object of a class
        that has
        members which are references to garbage collected objects, those
        references may no longer be valid. This means that destructors
        cannot reference sub objects.)

        $(NOTE This rule does not apply to a `scope` class instance or an object destructed
        with `destroy`, as the destructor is not being run
        during a garbage collection cycle, meaning all references are valid.)
        )

        $(P Objects referenced from the static data segment never get collected
        by the GC.
        )

$(H2 $(LNAME2 static-constructor, Static Constructors))

$(GRAMMAR
$(GNAME StaticConstructor):
    $(D static this ( )) $(GLINK2 function, MemberFunctionAttributes)$(OPT) $(GLINK2 function, FunctionBody)
)

        $(P A static constructor is a function that performs initializations of
        thread local data before the $(D main()) function gets control for the main
        thread, and upon thread startup.)

        $(P Static constructors are used to initialize static class members with
        values that cannot be computed at compile time.)

        $(P Static constructors in other languages are built implicitly by using
        member
        initializers that can't be computed at compile time. The trouble with
        this stems from not
        having good control over exactly when the code is executed, for example:
        )

------
class Foo
{
    static int a = b + 1;
    static int b = a * 2;
}
------

        What values do a and b end up with, what order are the initializations
        executed in, what
        are the values of a and b before the initializations are run, is this a
        compile error, or is this
        a runtime error? Additional confusion comes from it not being obvious if
        an initializer is
        static or dynamic.

        $(P D makes this simple. All member initializations must be determinable by
        the compiler at
        compile time, hence there is no order-of-evaluation dependency for
        member
        initializations, and it is not possible to read a value that has not
        been initialized. Dynamic
        initialization is performed by a static constructor, defined with
        a special syntax $(D static this()).)

------
class Foo
{
    static int a;         // default initialized to 0
    static int b = 1;
    static int c = b + a; // error, not a constant initializer

    $(CODE_HIGHLIGHT static this)()    // static constructor
    {
        a = b + 1;          // a is set to 2
        b = a * 2;          // b is set to 4
    }
}
------

$(P If $(D main()) or the thread returns normally, (does not throw an
exception), the static destructor is added to the list of functions to be called
on thread termination.)

$(P Static constructors have empty parameter lists.)

        $(P
        Static constructors within a module are executed in the lexical
        order in which they appear.
        All the static constructors for modules that are directly or
        indirectly imported
        are executed before the static constructors for the importer.
        )

        $(P
        The $(D static) in the static constructor declaration is not
        an attribute, it must appear immediately before the $(D this):
        )

------
class Foo
{
    static this() { ... } // a static constructor
    static private this() { ... } // not a static constructor
    static
    {
        this() { ... }      // not a static constructor
    }
    static:
        this() { ... }      // not a static constructor
}
------

$(H2 $(LNAME2 static-destructor, Static Destructors))

$(GRAMMAR
$(GNAME StaticDestructor):
    $(D static ~ this ( )) $(GLINK2 function, MemberFunctionAttributes)$(OPT) $(GLINK2 function, FunctionBody)
)

        A static destructor is defined as a special static function with the
        syntax $(D static ~this()).

------
class Foo
{
    static ~this() // static destructor
    {
    }
}
------

        $(P
        A static destructor gets called on thread termination,
        but only if the static constructor
        completed successfully.
        Static destructors have empty parameter lists.
        Static destructors get called in the reverse order that the static
        constructors were called in.
        )

        $(P
        The $(D static) in the static destructor declaration is not
        an attribute, it must appear immediately before the $(D ~this):
        )

------
class Foo
{
    static ~this() { ... }  // a static destructor
    static private ~this() { ... } // not a static destructor
    static
    {
        ~this() { ... }  // not a static destructor
    }
    static:
        ~this() { ... }  // not a static destructor
}
------

$(H2 $(LNAME2 shared_static_constructors, Shared Static Constructors))

$(GRAMMAR
$(GNAME SharedStaticConstructor):
    $(D shared static this ( )) $(GLINK2 function, MemberFunctionAttributes)$(OPT) $(GLINK2 function, FunctionBody)
)

        $(P Shared static constructors are executed before any $(GLINK StaticConstructor)s,
        and are intended for initializing any shared global data.
        )

$(H2 $(LNAME2 shared_static_destructors, Shared Static Destructors))

$(GRAMMAR
$(GNAME SharedStaticDestructor):
    $(D shared static ~ this ( )) $(GLINK2 function, MemberFunctionAttributes)$(OPT) $(GLINK2 function, FunctionBody)
)

        $(P Shared static destructors are executed at program termination
        in the reverse order that
        $(GLINK SharedStaticConstructor)s were executed.
        )


$(H2 $(LNAME2 invariants, Class Invariants))

$(GRAMMAR
$(GNAME Invariant):
    $(D invariant $(LPAREN) $(RPAREN)) $(GLINK2 statement, BlockStatement)
    $(D invariant) $(GLINK2 statement, BlockStatement)
    $(D invariant $(LPAREN)) $(GLINK2 expression, AssertArguments) $(D $(RPAREN) ;)
)

    $(P Class $(I Invariant)s specify the relationships among the members of a class instance.
    Those relationships must hold for any interactions with the instance from its
    public interface.
    )

    $(P The invariant is in the form of a $(D const) member function. The invariant is defined
    to $(I hold) if all the $(GLINK2 expression, AssertExpression)s within the invariant that are executed
    succeed.
    )

    $(SPEC_RUNNABLE_EXAMPLE_COMPILE
    ---
    class Date
    {
        this(int d, int h)
        {
            day = d;    // days are 1..31
            hour = h;   // hours are 0..23
        }

        invariant
        {
            assert(1 <= day && day <= 31);
            assert(0 <= hour && hour < 24);
        }

      private:
        int day;
        int hour;
    }
    ---
    )

    $(P Any class invariants for base classes are applied before the class invariant for the derived class.)

    $(P There may be multiple invariants in a class. They are applied in lexical order.)

    $(P Class $(I Invariant)s must hold at the exit of the class constructor (if any), and
    at the entry of the class destructor (if any).)

    $(P Class $(I Invariant)s must hold
    at the entry and exit of all public or exported non-static member functions.
    The order of application of invariants is:)
    $(OL
    $(LI preconditions)
    $(LI invariant)
    $(LI function body)
    $(LI invariant)
    $(LI postconditions)
    )

    $(P If the invariant does not hold, then the program enters an invalid state.)

    $(IMPLEMENTATION_DEFINED
    $(OL
    $(LI Whether the class $(I Invariant) is executed at runtime or not. This is typically
    controlled with a compiler switch.)
    $(LI The behavior when the invariant does not hold is typically the same as
    for when $(GLINK2 expression, AssertExpression)s fail.)
    )
    )

    $(UNDEFINED_BEHAVIOR happens if the invariant does not hold and execution continues.)

    $(P Public or exported non-static member functions cannot be called from within an invariant.)

    ---
    class Foo
    {
        public void f() { }
        private void g() { }

        invariant
        {
            f();  // error, cannot call public member function from invariant
            g();  // ok, g() is not public
        }
    }
    ---

    $(BEST_PRACTICE
    $(OL
    $(LI Do not indirectly call exported or public member functions within a class invariant,
    as this can result in infinite recursion.)
    $(LI Avoid reliance on side effects in the invariant. as the invariant may or may not
    be executed.)
    $(LI Avoid having mutable public fields of classes with invariants,
    as then the invariant cannot verify the public interface.)
    )
    )


$(H2 $(LNAME2 auto, Scope Classes))
$(NOTE Scope classes have been $(DDSUBLINK deprecate, scope as a type constraint,  deprecated). See also
$(DDSUBLINK spec/attribute, scope-class-var, `scope` class instances).)

        $(P A scope class is a class with the $(D scope) attribute, as in:)

------
scope class Foo { ... }
------

$(P The scope characteristic is inherited, so any classes derived from a scope
class are also scope.)

        $(P A scope class reference can only appear as a function local variable.
        It must be declared as being $(D scope):)

------
scope class Foo { ... }

void func()
{
    Foo f;    // error, reference to scope class must be scope
    scope Foo g = new Foo(); // correct
}
------

$(P When a scope class reference goes out of scope, the destructor (if any) for
it is automatically called. This holds true even if the scope was exited via a
thrown exception.)


$(H2 $(LNAME2 abstract, Abstract Classes))

$(P
        An abstract member function must be overridden by a derived class.
        Only virtual member functions may be declared abstract; non-virtual
        member functions and free-standing functions cannot be declared
        abstract.
)

$(P
        A class is abstract if any of its virtual member functions
        are declared abstract or if they are defined within an
        abstract attribute.
        Note that an abstract class may also contain non-virtual member functions.
        Abstract classes cannot be instantiated directly.
        They can only be instantiated as a base class of
        another, non-abstract, class.
)

$(SPEC_RUNNABLE_EXAMPLE_FAIL
---
class C
{
    abstract void f();
}

auto c = new C; // error, C is abstract

class D : C {}

auto d = new D; // error, D is abstract

class E : C
{
    override void f() {}
}

auto e = new E; // OK
---
)

$(P
        Member functions declared as abstract can still have function
        bodies. This is so that even though they must be overridden,
        they can still provide $(SINGLEQUOTE base class functionality),
        e.g. through $(DDSUBLINK spec/expression, super, $(D super.foo())) in a derived class.
        Note that the class is still abstract and cannot be instantiated directly.
)

$(P
        A class can be declared abstract:
)

$(SPEC_RUNNABLE_EXAMPLE_FAIL
---
abstract class A
{
    // ...
}

auto a = new A; // error, A is abstract

class B : A {}

auto b = new B; // OK
---
)


$(H2 $(LNAME2 final, Final Classes))

        $(P Final classes cannot be subclassed:)

---
final class A { }
class B : A { }  // error, class A is final
---

        $(P Methods of a final class are always
        $(DDSUBLINK spec/function, final, `final`).)

$(H2 $(LNAME2 nested, Nested Classes))

$(P A $(I nested class) is a class that is declared inside the scope of a
function or another class. A nested class has access to the variables and other
symbols of the classes and functions it is nested inside:)

------
class Outer
{
    int m;

    class Inner
    {
        int foo()
        {
            return m;   // Ok to access member of Outer
        }
    }
}
---
---
void func()
{
    int m;

    class Inner
    {
        int foo()
        {
            return m; // Ok to access local variable m of func()
        }
    }
}
------

$(H3 $(LNAME2 static-nested, Static Nested Classes))

$(P If a nested class has the $(D static) attribute, then it can not access
variables of the enclosing scope that are local to the stack or need a
`this` reference:)

------
class Outer
{
    int m;
    static int n;

    static class Inner
    {
        int foo()
        {
            return m;   // Error, Inner is static and m needs a this
            return n;   // Ok, n is static
        }
    }
}
---
---
void func()
{
    int m;
    static int n;

    static class Inner
    {
        int foo()
        {
            return m;   // Error, Inner is static and m is local to the stack
            return n;   // Ok, n is static
        }
    }
}
------

$(H3 $(LNAME2 nested-context, Context Pointer))

$(P Non-static nested classes work by containing an extra hidden member (called
the context pointer) that is the frame pointer of the enclosing function if it
is nested inside a function, or the $(D this) reference of the enclosing class's instance
if it is nested inside a class.)

        $(P When a non-static nested class is instantiated, the context pointer
        is assigned before the class's constructor is called, therefore
        the constructor has full access to the enclosing variables.
        A non-static nested class can only be instantiated when the necessary
        context pointer information is available:)

$(SPEC_RUNNABLE_EXAMPLE_COMPILE
------
class Outer
{
    class Inner { }

    static class SInner { }
}

void main()
{
    Outer o = new Outer;        // Ok
    //Outer.Inner oi = new Outer.Inner; // Error, no 'this' for Outer
    Outer.SInner os = new Outer.SInner; // Ok
}
---
)

$(SPEC_RUNNABLE_EXAMPLE_COMPILE
---
void main()
{
    class Nested { }

    Nested n = new Nested;      // Ok

    static f()
    {
        //Nested sn = new Nested; // Error, no 'this' for Nested
    }
}
------
)

$(H3 $(LNAME2 nested-explicit, Explicit Instantiation))

        $(P A `this` reference can be supplied to the creation of an
        inner class instance by prefixing it to the $(I NewExpression):
        )

$(SPEC_RUNNABLE_EXAMPLE_RUN
---------
class Outer
{
    int a;

    class Inner
    {
        int foo()
        {
            return a;
        }
    }
}

void main()
{
    Outer o = new Outer;
    o.a = 3;
    Outer.Inner oi = o.new Inner;
    assert(oi.foo() == 3);
}
---------
)

        $(P Here $(D o) supplies the `this` reference to the inner class
        instance of $(D Outer).
        )

$(H3 $(LNAME2 outer-property, `outer` Property))

        $(P For a nested class instance, the $(D .outer) property provides
        the $(D this) reference of the enclosing class's instance.
        If there is no accessible parent class instance, the property
        provides a $(D void*) to the enclosing function frame.)

----
class Outer
{
    class Inner1
    {
        Outer getOuter()
        {
            return this.$(CODE_HIGHLIGHT outer);
        }
    }

    void foo()
    {
        Inner1 i = new Inner1;
        assert(i.getOuter() is this);
    }
}
---
---
class Outer
{
    void bar()
    {
        // x is referenced from nested scope, so
        // bar makes a closure environment.
        int x = 1;

        class Inner2
        {
            Outer getOuter()
            {
                x = 2;
                // The Inner2 instance has access to the function frame
                // of bar as a static frame pointer, but .outer returns
                // the enclosing Outer class instance property.
                return this.$(CODE_HIGHLIGHT outer);
            }
        }

        Inner2 i = new Inner2;
        assert(i.getOuter() is this);
    }
}
---
---
class Outer
{
    // baz cannot access an instance of Outer
    static void baz()
    {
        // make a closure environment
        int x = 1;

        class Inner3
        {
            void* getOuter()
            {
                x = 2;
                // There's no accessible enclosing class instance, so the
                // .outer property returns the function frame of baz.
                return this.$(CODE_HIGHLIGHT outer);
            }
        }

        Inner3 i = new Inner3;
        assert(i.getOuter() !is null);
    }
}
----

$(H3 $(LNAME2 anonymous, Anonymous Nested Classes))

        $(P An anonymous nested class is both defined and instantiated with
        a $(I NewAnonClassExpression):
        )

$(GRAMMAR
$(GNAME NewAnonClassExpression):
    $(D new) $(D class) $(GLINK ConstructorArgs)$(OPT) $(GLINK AnonBaseClassList)$(OPT) $(GLINK2 struct, AggregateBody)

$(GNAME ConstructorArgs):
    $(D $(LPAREN)) $(GLINK2 expression, NamedArgumentList)$(OPT) $(D $(RPAREN))

$(GNAME AnonBaseClassList):
    $(GLINK SuperClassOrInterface)
    $(GLINK SuperClassOrInterface) $(D ,) $(GLINK Interfaces)
)

which is equivalent to:

$(GRAMMAR_INFORMATIVE
$(D class) $(GLINK_LEX Identifier) $(D :) $(I AnonBaseClassList) $(I AggregateBody)
// ...
$(D new) $(I Identifier) $(I ConstructorArgs)
)

where $(I Identifier) is the name generated for the anonymous nested class.

$(SPEC_RUNNABLE_EXAMPLE_RUN
---
interface I
{
    void foo();
}

auto obj = new class I
{
    void foo()
    {
        writeln("foo");
    }
};
obj.foo();
---
)

$(SECTION2 $(LEGACY_LNAME2 ConstClass, const-class, $(ARGS Const, Immutable and Shared Classes)),

    $(P If a $(I ClassDeclaration) has a $(D const), $(D immutable)
        or $(D shared) storage class, then it is as if each member of the class
        was declared with that storage class.
        If a base class is const, immutable or shared, then all classes derived
        from it are also const, immutable or shared.
    )
)
$(SPEC_SUBNAV_PREV_NEXT struct, Structs and Unions, interface, Interfaces)
)

Macros:
        CHAPTER=16
        TITLE=Classes
        _=
