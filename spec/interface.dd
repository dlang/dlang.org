Ddoc

$(SPEC_S Interfaces,

$(HEADERNAV_TOC)

    $(P An $(I Interface) abstracts from common behaviour in terms of an abstract class
    which doesn't expose implementation details of methods and object state.
    Classes which inherit from an interface must implement the functions' signatures.)

$(GRAMMAR
$(GNAME InterfaceDeclaration):
    $(D interface) $(GLINK_LEX Identifier) $(D ;)
    $(D interface) $(GLINK_LEX Identifier) $(GLINK BaseInterfaceList)$(OPT) $(GLINK2 struct, AggregateBody)
    $(GLINK2 template, InterfaceTemplateDeclaration)

$(GNAME BaseInterfaceList):
    $(D :) $(GLINK2 class, Interfaces)
)

    $(IMPLEMENTATION_DEFINED $(P Specialized interfaces may be supported:)

    $(OL
    $(LI $(RELATIVE_LINK2 com-interfaces, $(I COM Interfaces))
    are binary compatible with COM/OLE/ActiveX objects for Windows.
    )

    $(LI $(RELATIVE_LINK2 cpp-interfaces, $(I C++ Interfaces))
    are binary compatible with C++ abstract classes.
    )

    $(LI [Objective-C Interfaces](objc_interface.html#protocols)
    are binary compatible with Objective-C protocols.
    )
    )
    )


    $(P A class that implements an interface can be implicitly converted to a reference
    to that interface.)

    $(P Interfaces cannot derive from classes; only from other interfaces.
    Classes cannot derive from the same interface multiple times.
    )

------
interface D
{
    void foo();
}

class A : D, D  // error, duplicate interface
{
}
------

$(P An instance of an interface cannot be created.)

------
interface D
{
    void foo();
}

...

D d = new D();  // error, cannot create instance of interface
------


    $(P Interfaces may provide definitions of members, but such members must be `static`, be templated or functions must be `final`.
    )

------
interface D
{
    void bar() { }  // error, implementation not allowed
    static void foo() { } // ok
    final void abc() { } // ok
}
------

     $(P Non-static member fields may not be defined in interfaces.
     )

------
interface D
{
    static immutable e = 2.71828f;   // ok
    float f;  // error, variable `f` field not allowed in interface
    immutable g = 3.81f;  // error, variable `g` field not allowed in interface
    enum h = 6.626f;  // ok, compile-time-static symbols are considered static
}
------

     $(P Interfaces can have member templates.
         All instantiated member templates are implicitly `final`.
     )

---
interface D
{
    void foo(T)() { }  // ok, it's implicitly final
    T chameleon(T) = T.init; // ok, it's implicitly final
}
---

    $(P Classes that inherit from an interface may not override final or
    static interface member functions.)

------
interface D
{
    void bar();
    static void foo() { }
    final void abc() { }
    static void xyz() { }
    static int bla = 0;
}

class C : D
{
    void bar() { } // ok
    static void xyz() { } // ok, but does not override D.xyz()
    override static void foo() { } // error, cannot override non-virtual function D.foo()
    void abc() { } // error, cannot override final D.abc()
    static int bla = 1; // ok, but does not override D.bla
}
------


    $(P All interface functions must be defined in a class that inherits
    from that interface:
    )
------
interface D
{
    void foo();
}

class A : D
{
    void foo() { }  // ok, provides implementation
}

class B : D
{
    int foo() { }   // error, no void foo() implementation
}
------

$(P Interfaces can be inherited and functions overridden:)

------
interface D
{
    int foo();
}

class A : D
{
    int foo() { return 1; }
}

class B : A
{
    int foo() { return 2; }
}

...

B b = new B();
b.foo();            // returns 2
D d = cast(D) b;    // ok since B inherits A's D implementation
d.foo();            // returns 2;
------

    $(P Member definitions are only imported from an interface into a class if the symbol does not exist in that class already.)

------
interface D
{
    static int foo() { return 3; }
    int foo(T)() { return 10; }
}

interface E
{
    static int foo(int x) { return 4; }
}

class A : D, E  // imports D.foo
{
}

class B : E, D  // imports E.foo
{
}

class C : D, E  // neither imports D.foo nor E.foo
{
    T foo(T : float)(T f) { return f; }
}

...

A a = new A();
a.foo(5);  // error
a.foo();  // returns 3
a.foo!double();  // returns 10

B b = new B();
b.foo(5);  // returns 4
b.foo();  // error
b.foo!double();  // error

C c = new C();
c.foo(5);  // returns 5
c.foo();  // error
c.foo!double();  // error

E e = cast(E) c;
e.foo(5);  // returns 4
------

    $(P Interfaces can be reimplemented in derived classes:)

------
interface D
{
    int foo();
}

class A : D
{
    int foo() { return 1; }
}

class B : A, D
{
    int foo() { return 2; }
}

...

B b = new B();
b.foo();            // returns 2
D d = cast(D) b;
d.foo();            // returns 2
A a = cast(A) b;
D d2 = cast(D) a;
d2.foo();           // returns 2, even though it is A's D, not B's D
------

    $(P A reimplemented interface must implement all the interface
    functions, it does not inherit them from a super class:
    )

------
interface D
{
    int foo();
}

class A : D
{
    int foo() { return 1; }
}

class B : A, D
{
}       // error, no foo() for interface D
------

$(SECTION2 $(LEGACY_LNAME2 InterfaceContracts, interface-contracts, Interfaces with Contracts),

    $(P Interface member functions can have contracts even though there
    is no body for the function. The contracts are inherited by any
    class member function that implements that interface member function.
    )

---
interface I
{
    int foo(int i)
    in { assert(i > 7); }
    out (result) { assert(result & 1); }

    void bar();
}
---
)

$(SECTION2 $(LEGACY_LNAME2 ConstInterface, const-interface, Const and Immutable Interfaces),
    $(P If an interface has $(CODE const) or $(CODE immutable) storage
    class, then all members of the interface are
    $(CODE const) or $(CODE immutable).
    This storage class is not inherited.
    )
)


$(SECTION2 $(LEGACY_LNAME2 COM-Interfaces, com-interfaces, COM Interfaces),

    $(P A variant on interfaces is the COM interface. A COM interface is
    designed to map directly onto a Windows COM object. Any COM object
    can be represented by a COM interface, and any D object with
    a COM interface can be used by external COM clients.
    )

    $(P A COM interface is defined as one that derives from the interface
    $(D core.stdc.win)$(SHY)$(D dows.com.IUnknown). A COM interface differs from
    a regular D interface in that:
    )

    $(UL
    $(LI It derives from the interface $(D core.stdc.windows.com.IUnknown).)
    $(LI It cannot be the argument to $(REF1 destroy, object).)
    $(LI References cannot be upcast to the enclosing class object, nor
    can they be downcast to a derived interface.
    Implement $(D QueryInterface())
    for that interface in standard COM fashion to convert to another COM interface.)
    $(LI Classes derived from COM interfaces are COM classes.)
    $(LI The default linkage for member functions of COM classes
    is $(D extern(System)).

    $(NOTE To implement or override any base-class methods of
    D interfaces or classes (ones which do not inherit from $(D IUnknown)),
    explicitly mark them as having the $(D extern(D)) linkage.)

    ---
    import core.sys.windows.windows;
    import core.stdc.windows.com;

    interface IText
    {
        void write();
    }

    abstract class Printer : IText
    {
        void print() { }
    }

    class C : Printer, IUnknown
    {
        // Implements the IText `write` class method.
        extern(D) void write() { }

        // Overrides the Printer `print` class method.
        extern(D) override void print() { }

        // Overrides the Object base class `toString` method.
        extern(D) override string toString() { return "Class C"; }

        // Methods of class implementing the IUnknown interface have
        // the extern(System) calling convention by default.
        HRESULT QueryInterface(const(IID)*, void**);
        uint AddRef();
        uint Release();
    }
    ---

    $(P The same applies to other $(D Object) methods such as $(D opCmp), $(D toHash), etc.)

    )
    $(LI The first member of the COM $(D vtbl[]) is not the pointer
    to the InterfaceInfo, but the first virtual function pointer.)
    )

    $(P See also
    $(LINK2 http://www.lunesu.com/uploads/ModernCOMProgramminginD.pdf, Modern COM Programming in D)
    )

)

$(SECTION2 $(LEGACY_LNAME2 CPP-Interfaces, cpp-interfaces, C++ Interfaces),

    $(P C++ interfaces are interfaces declared with C++ linkage:
    )

---
extern (C++) interface Ifoo
{
    void foo();
    void bar();
}
---

which is meant to correspond with the following C++ declaration:

$(CPPLISTING
class Ifoo
{
    virtual void foo();
    virtual void bar();
};
)

    $(P Any interface that derives from a C++ interface is also
    a C++ interface.
    A C++ interface differs from a D interface in that:
    )

    $(UL
    $(LI It cannot be the argument to $(REF1 destroy, object).)
    $(LI References cannot be upcast to the enclosing class object, nor
    can they be downcast to a derived interface.)
    $(LI The C++ calling convention is the default convention
    for its member functions, rather than the D calling convention.)
    $(LI The first member of the $(D vtbl[]) is not the pointer
    to the $(D Interface), but the first virtual function pointer.)
    )
)


$(SPEC_SUBNAV_PREV_NEXT class, Classes, enum, Enums)
)

Macros:
    CHAPTER=16
    TITLE=Interfaces
