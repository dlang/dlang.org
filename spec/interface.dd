Ddoc

$(SPEC_S Interfaces,

$(HEADERNAV_TOC)

$(H2 $(LNAME2 declarations, Interface Declarations))

    $(P An $(I Interface) describes a list of functions that a class which inherits
    from the interface must implement.)

$(GRAMMAR
$(GNAME InterfaceDeclaration):
    $(D interface) $(GLINK_LEX Identifier) $(D ;)
    $(D interface) $(GLINK_LEX Identifier) $(GLINK BaseInterfaceList)$(OPT) $(GLINK2 struct, AggregateBody)
    $(GLINK2 template, InterfaceTemplateDeclaration)

$(GNAME BaseInterfaceList):
    $(D :) $(GLINK2 class, Interfaces)
)

    $(IMPLEMENTATION_DEFINED $(P Specialized interfaces may be supported:)

    $(OL
    $(LI $(RELATIVE_LINK2 com-interfaces, $(I COM Interfaces))
    are binary compatible with COM/OLE/ActiveX objects for Windows.
    )

    $(LI $(RELATIVE_LINK2 cpp-interfaces, $(I C++ Interfaces))
    are binary compatible with C++ abstract classes.
    )

    $(LI [Objective-C Interfaces](objc_interface.html#protocols)
    are binary compatible with Objective-C protocols.
    )
    )
    )


    $(P A class that implements an interface can be implicitly converted to a reference
    to that interface.)

    $(P Interfaces cannot derive from classes; only from other interfaces.
    Classes cannot derive from an interface multiple times.
    )

------
interface I
{
    void foo();
}

class A : I, I  // error, duplicate interface
{
}
------

$(P An instance of an interface cannot be created.)

------
interface I
{
    void foo();
}

...

I iface = new I();  // error, cannot create instance of interface
------

$(H3 $(LNAME2 method-bodies, Interface Method Bodies))

    $(P Virtual interface member functions do not have implementations.
    Interfaces are expected to implement static or final functions.
    )

------
interface I
{
    void bar() { }  // error, implementation not allowed
    static void foo() { } // ok
    final void abc() { } // ok
}
------

     $(P Interfaces can have function templates in the members.
         All instantiated functions are implicitly `final`.
     )

---
interface I
{
    void foo(T)() { }  // ok, it's implicitly final
}
---

    $(P Classes that inherit from an interface may not override final or
    static interface member functions.)

------
interface I
{
    void bar();
    static void foo() { }
    final void abc() { }
}

class C : I
{
    void bar() { } // ok
    void foo() { } // error, cannot override static I.foo()
    void abc() { } // error, cannot override final I.abc()
}
------

$(H3 $(LNAME2 implementing-interfaces, Implementing Interfaces))

    $(P All virtual interface functions must be defined in a class that inherits
    from that interface:
    )
------
interface I
{
    void foo();
}

class A : I
{
    void foo() { }  // ok, provides implementation
}

class B : I
{
    int foo() { }   // error, no `void foo()` implementation
}
------

$(P Interfaces can be inherited from a base class, and interface functions overridden:)

$(SPEC_RUNNABLE_EXAMPLE_RUN
------
interface I
{
    int foo();
}

class A : I
{
    int foo() { return 1; }
}

class B : A
{
    override int foo() { return 2; }
}

B b = new B();
assert(b.foo() == 2);

I i = b;    // ok since B inherits A's I implementation
assert(i.foo() == 2);
------
)

$(H4 $(LNAME2 reimplementing-interfaces, Reimplementing Interfaces))

    $(P Interfaces can be reimplemented in derived classes:)

$(SPEC_RUNNABLE_EXAMPLE_RUN
------
interface I
{
    int foo();
}

class A : I
{
    int foo() { return 1; }
}

class B : A, I
{
    override int foo() { return 2; }
}

B b = new B();
assert(b.foo() == 2);
I i = b;
assert(i.foo() == 2);

A a = b;
I i2 = a;
assert(i2.foo() == 2); // i2 has A's virtual pointer for foo which points to B.foo
------
)

    $(P A reimplemented interface must implement all the interface
    functions, it does not inherit them from a super class:
    )

------
interface I
{
    int foo();
}

class A : I
{
    int foo() { return 1; }
}

class B : A, I
{
}       // error, no foo() for interface I
------

$(SECTION3 $(LEGACY_LNAME2 InterfaceContracts, interface-contracts, Interface Method Contracts),

    $(P Interface member functions can have contracts even though there
    is no body for the function. The contracts are inherited by any
    class member function that implements that interface member function.
    )

---
interface I
{
    int foo(int i)
    in { assert(i > 7); }
    out (result) { assert(result & 1); }

    void bar();
}
---
)

$(SECTION3 $(LEGACY_LNAME2 ConstInterface, const-interface, Const and Immutable Interfaces),
    $(P If an interface has $(CODE const) or $(CODE immutable) storage
    class, then all members of the interface are
    $(CODE const) or $(CODE immutable).
    This storage class is not inherited.
    )
)


$(SECTION2 $(LEGACY_LNAME2 COM-Interfaces, com-interfaces, COM Interfaces),

    $(P A variant on interfaces is the COM interface. A COM interface is
    designed to map directly onto a Windows COM object. Any COM object
    can be represented by a COM interface, and any D object with
    a COM interface can be used by external COM clients.
    )

    $(P A COM interface is defined as one that derives from the interface
    $(D core.sys.win)$(SHY)$(D dows.com.IUnknown). A COM interface differs from
    a regular D interface in that:
    )

    $(UL
    $(LI It derives from the interface $(D core.sys.windows.com.IUnknown).)
    $(LI It cannot be the argument to $(REF1 destroy, object).)
    $(LI References cannot be upcast to the enclosing class object, nor
    can they be downcast to a derived interface.
    Implement $(D QueryInterface())
    for that interface in standard COM fashion to convert to another COM interface.)
    $(LI Classes derived from COM interfaces are COM classes.)
    $(LI The default linkage for member functions of COM classes
    is $(D extern(System)).

    $(NOTE To implement or override any base-class methods of
    D interfaces or classes (ones which do not inherit from $(D IUnknown)),
    explicitly mark them as having the $(D extern(D)) linkage.)

    ---
    import core.sys.windows.windows;
    import core.sys.windows.com;

    interface IText
    {
        void write();
    }

    abstract class Printer : IText
    {
        void print() { }
    }

    class C : Printer, IUnknown
    {
        // Implements the IText `write` class method.
        extern(D) void write() { }

        // Overrides the Printer `print` class method.
        extern(D) override void print() { }

        // Overrides the Object base class `toString` method.
        extern(D) override string toString() { return "Class C"; }

        // Methods of class implementing the IUnknown interface have
        // the extern(System) calling convention by default.
        HRESULT QueryInterface(const(IID)*, void**);
        uint AddRef();
        uint Release();
    }
    ---

    $(P The same applies to other $(D Object) methods such as $(D opCmp), $(D toHash), etc.)

    )
    $(LI The first member of the COM $(D vtbl[]) is not the pointer
    to the InterfaceInfo, but the first virtual function pointer.)
    )

    $(P See also
    $(LINK2 http://www.lunesu.com/uploads/ModernCOMProgramminginD.pdf, Modern COM Programming in D)
    )

)

$(SECTION2 $(LEGACY_LNAME2 CPP-Interfaces, cpp-interfaces, C++ Interfaces),

    $(P C++ interfaces are interfaces declared with C++ linkage:
    )

---
extern (C++) interface Ifoo
{
    void foo();
    void bar();
}
---

which is meant to correspond with the following C++ declaration:

$(CPPLISTING
class Ifoo
{
    virtual void foo();
    virtual void bar();
};
)

    $(P Any interface that derives from a C++ interface is also
    a C++ interface.
    A C++ interface differs from a D interface in that:
    )

    $(UL
    $(LI It cannot be the argument to $(REF1 destroy, object).)
    $(LI References cannot be upcast to the enclosing class object, nor
    can they be downcast to a derived interface.)
    $(LI The C++ calling convention is the default convention
    for its member functions, rather than the D calling convention.)
    $(LI The first member of the $(D vtbl[]) is not the pointer
    to the $(D Interface), but the first virtual function pointer.)
    )
)


$(SPEC_SUBNAV_PREV_NEXT class, Classes, enum, Enums)
)

Macros:
    CHAPTER=16
    TITLE=Interfaces
